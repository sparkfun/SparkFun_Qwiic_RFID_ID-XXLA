
C:\Users\Elias\AppData\Local\Temp\arduino_build_340013/Qwiic_RFID_IDXXLA.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	2d c0       	rjmp	.+90     	; 0x5c <__dtors_end>
   2:	51 c0       	rjmp	.+162    	; 0xa6 <__bad_interrupt>
   4:	70 c3       	rjmp	.+1760   	; 0x6e6 <__vector_2>
   6:	6f c3       	rjmp	.+1758   	; 0x6e6 <__vector_2>
   8:	4e c0       	rjmp	.+156    	; 0xa6 <__bad_interrupt>
   a:	4d c0       	rjmp	.+154    	; 0xa6 <__bad_interrupt>
   c:	4c c0       	rjmp	.+152    	; 0xa6 <__bad_interrupt>
   e:	4b c0       	rjmp	.+150    	; 0xa6 <__bad_interrupt>
  10:	4a c0       	rjmp	.+148    	; 0xa6 <__bad_interrupt>
  12:	49 c0       	rjmp	.+146    	; 0xa6 <__bad_interrupt>
  14:	48 c0       	rjmp	.+144    	; 0xa6 <__bad_interrupt>
  16:	1d c3       	rjmp	.+1594   	; 0x652 <__vector_11>
  18:	46 c0       	rjmp	.+140    	; 0xa6 <__bad_interrupt>
  1a:	45 c0       	rjmp	.+138    	; 0xa6 <__bad_interrupt>
  1c:	44 c0       	rjmp	.+136    	; 0xa6 <__bad_interrupt>
  1e:	92 c4       	rjmp	.+2340   	; 0x944 <__vector_15>
  20:	da c3       	rjmp	.+1972   	; 0x7d6 <__vector_16>

00000022 <__trampolines_end>:
__trampolines_start():
  22:	00 00       	nop
  24:	39 00       	.word	0x0039	; ????
  26:	36 00       	.word	0x0036	; ????

00000028 <port_to_mode_PGM>:
  28:	00 00 3a 00 37 00                                   ..:.7.

0000002e <port_to_output_PGM>:
  2e:	00 00 3b 00 38 00                                   ..;.8.

00000034 <digital_pin_to_port_PGM>:
  34:	01 01 01 01 01 01 01 01 02 02 02 02                 ............

00000040 <digital_pin_to_bit_mask_PGM>:
  40:	01 02 04 08 10 20 40 80 04 02 01 08                 ..... @.....

0000004c <digital_pin_to_timer_PGM>:
  4c:	00 00 00 00 00 04 03 02 01 00 00 00                 ............

00000058 <__ctors_start>:
__ctors_start():
  58:	77 06       	cpc	r7, r23

0000005a <__ctors_end>:
__dtors_start():
  5a:	df 06       	cpc	r13, r31

0000005c <__dtors_end>:
__dtors_end():
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf e5       	ldi	r28, 0x5F	; 95
  62:	d2 e0       	ldi	r29, 0x02	; 2
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  68:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  6a:	a2 e7       	ldi	r26, 0x72	; 114
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  6c:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  6e:	01 c0       	rjmp	.+2      	; 0x72 <.do_clear_bss_start>

00000070 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  70:	1d 92       	st	X+, r1

00000072 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  72:	a4 3f       	cpi	r26, 0xF4	; 244
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  74:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  76:	e1 f7       	brne	.-8      	; 0x70 <.do_clear_bss_loop>

00000078 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  78:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  7a:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  7c:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  7e:	e6 eb       	ldi	r30, 0xB6	; 182
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  80:	fe e0       	ldi	r31, 0x0E	; 14
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  82:	02 c0       	rjmp	.+4      	; 0x88 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  84:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  86:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  88:	a2 37       	cpi	r26, 0x72	; 114
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  8a:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  8c:	d9 f7       	brne	.-10     	; 0x84 <__do_copy_data+0xc>

0000008e <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  8e:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  90:	cd e2       	ldi	r28, 0x2D	; 45
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  92:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  94:	03 c0       	rjmp	.+6      	; 0x9c <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  96:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  98:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  9a:	fb d6       	rcall	.+3574   	; 0xe92 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  9c:	cc 32       	cpi	r28, 0x2C	; 44
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  9e:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  a0:	d1 f7       	brne	.-12     	; 0x96 <__do_global_ctors+0x8>
  a2:	97 d4       	rcall	.+2350   	; 0x9d2 <main>
  a4:	fc c6       	rjmp	.+3576   	; 0xe9e <__do_global_dtors>

000000a6 <__bad_interrupt>:
__vector_1():
  a6:	ac cf       	rjmp	.-168    	; 0x0 <__vectors>

000000a8 <TwoWire::available() [clone .constprop.5]>:
_ZN7TwoWire9availableEv.constprop.5():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:545

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  if (BufferLength) {
  a8:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <TwoWire::BufferLength>
  ac:	88 23       	and	r24, r24
  ae:	29 f0       	breq	.+10     	; 0xba <TwoWire::available() [clone .constprop.5]+0x12>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:546
    return BufferLength - BufferIndex;
  b0:	90 91 f2 01 	lds	r25, 0x01F2	; 0x8001f2 <TwoWire::BufferIndex>
  b4:	89 1b       	sub	r24, r25
  b6:	99 0b       	sbc	r25, r25
  b8:	08 95       	ret
USI_TWI_Data_In_Receive_Buffer():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
  ba:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
  be:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_RxHead>
  c2:	89 1b       	sub	r24, r25
  c4:	8f 70       	andi	r24, 0x0F	; 15
_ZN7TwoWire9availableEv.constprop.5():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:548
  } else {
    return USI_TWI_Data_In_Receive_Buffer();
  c6:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:550
  }
}
  c8:	08 95       	ret

000000ca <TwoWire::read() [clone .constprop.4]>:
_ZN7TwoWire4readEv.constprop.4():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:559
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
  ca:	ee df       	rcall	.-36     	; 0xa8 <TwoWire::available() [clone .constprop.5]>
  cc:	89 2b       	or	r24, r25
  ce:	11 f1       	breq	.+68     	; 0x114 <TwoWire::read() [clone .constprop.4]+0x4a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:560
    if (BufferLength) {
  d0:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <TwoWire::BufferLength>
  d4:	88 23       	and	r24, r24
  d6:	61 f0       	breq	.+24     	; 0xf0 <TwoWire::read() [clone .constprop.4]+0x26>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:561
      value = Buffer[BufferIndex];
  d8:	20 91 f2 01 	lds	r18, 0x01F2	; 0x8001f2 <TwoWire::BufferIndex>
  dc:	e2 2f       	mov	r30, r18
  de:	f0 e0       	ldi	r31, 0x00	; 0
  e0:	ee 58       	subi	r30, 0x8E	; 142
  e2:	ff 4f       	sbci	r31, 0xFF	; 255
  e4:	80 81       	ld	r24, Z
  e6:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:562
      ++BufferIndex;
  e8:	2f 5f       	subi	r18, 0xFF	; 255
  ea:	20 93 f2 01 	sts	0x01F2, r18	; 0x8001f2 <TwoWire::BufferIndex>
  ee:	08 95       	ret
USI_TWI_Receive_Byte():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:112
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
  unsigned char tmptail;
  unsigned char tmpRxTail; // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
  f0:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:113
  while (TWI_RxHead == tmpRxTail)
  f4:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_RxHead>
  f8:	98 17       	cp	r25, r24
  fa:	e1 f3       	breq	.-8      	; 0xf4 <TwoWire::read() [clone .constprop.4]+0x2a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:115
    ;
  tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
  fc:	e0 91 f1 01 	lds	r30, 0x01F1	; 0x8001f1 <TWI_RxTail>
 100:	ef 5f       	subi	r30, 0xFF	; 255
 102:	ef 70       	andi	r30, 0x0F	; 15
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:116
  TWI_RxTail = tmptail;                               // Store new index
 104:	e0 93 f1 01 	sts	0x01F1, r30	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:117
  return TWI_RxBuf[tmptail];                          // Return data from the buffer.
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	ee 58       	subi	r30, 0x8E	; 142
 10c:	ff 4f       	sbci	r31, 0xFF	; 255
_ZN7TwoWire4readEv.constprop.4():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:564
    } else {
      value = USI_TWI_Receive_Byte();
 10e:	80 81       	ld	r24, Z
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:556

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
 114:	8f ef       	ldi	r24, 0xFF	; 255
 116:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:569
      value = USI_TWI_Receive_Byte();
    }
  }

  return value;
}
 118:	08 95       	ret

0000011a <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.cpp:34

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 11a:	cf 92       	push	r12
 11c:	df 92       	push	r13
 11e:	ef 92       	push	r14
 120:	ff 92       	push	r15
 122:	0f 93       	push	r16
 124:	1f 93       	push	r17
 126:	cf 93       	push	r28
 128:	df 93       	push	r29
 12a:	6c 01       	movw	r12, r24
 12c:	eb 01       	movw	r28, r22
 12e:	7b 01       	movw	r14, r22
 130:	e4 0e       	add	r14, r20
 132:	f5 1e       	adc	r15, r21
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.cpp:35
  size_t n = 0;
 134:	10 e0       	ldi	r17, 0x00	; 0
 136:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.cpp:36
  while (size--) {
 138:	ce 15       	cp	r28, r14
 13a:	df 05       	cpc	r29, r15
 13c:	61 f0       	breq	.+24     	; 0x156 <Print::write(unsigned char const*, unsigned int)+0x3c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.cpp:37
    n += write(*buffer++);
 13e:	69 91       	ld	r22, Y+
 140:	d6 01       	movw	r26, r12
 142:	ed 91       	ld	r30, X+
 144:	fc 91       	ld	r31, X
 146:	01 90       	ld	r0, Z+
 148:	f0 81       	ld	r31, Z
 14a:	e0 2d       	mov	r30, r0
 14c:	c6 01       	movw	r24, r12
 14e:	09 95       	icall
 150:	08 0f       	add	r16, r24
 152:	19 1f       	adc	r17, r25
 154:	f1 cf       	rjmp	.-30     	; 0x138 <Print::write(unsigned char const*, unsigned int)+0x1e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.cpp:40
  }
  return n;
}
 156:	c8 01       	movw	r24, r16
 158:	df 91       	pop	r29
 15a:	cf 91       	pop	r28
 15c:	1f 91       	pop	r17
 15e:	0f 91       	pop	r16
 160:	ff 90       	pop	r15
 162:	ef 90       	pop	r14
 164:	df 90       	pop	r13
 166:	cf 90       	pop	r12
 168:	08 95       	ret

0000016a <digitalWrite>:
digitalWrite():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:138
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	fc 01       	movw	r30, r24
 16e:	e4 5b       	subi	r30, 0xB4	; 180
 170:	ff 4f       	sbci	r31, 0xFF	; 255
 172:	34 91       	lpm	r19, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:139
  uint8_t bit = digitalPinToBitMask(pin);
 174:	fc 01       	movw	r30, r24
 176:	e0 5c       	subi	r30, 0xC0	; 192
 178:	ff 4f       	sbci	r31, 0xFF	; 255
 17a:	24 91       	lpm	r18, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:140
  uint8_t port = digitalPinToPort(pin);
 17c:	fc 01       	movw	r30, r24
 17e:	ec 5c       	subi	r30, 0xCC	; 204
 180:	ff 4f       	sbci	r31, 0xFF	; 255
 182:	e4 91       	lpm	r30, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:143
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 184:	ee 23       	and	r30, r30
 186:	b9 f0       	breq	.+46     	; 0x1b6 <digitalWrite+0x4c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:147

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 188:	33 23       	and	r19, r19
 18a:	29 f0       	breq	.+10     	; 0x196 <digitalWrite+0x2c>
turnOffPWM():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
  if( timer == TIMER0A){
 18c:	31 30       	cpi	r19, 0x01	; 1
 18e:	a1 f4       	brne	.+40     	; 0x1b8 <digitalWrite+0x4e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:68
    cbi(TCCR0A, COM0A1);
 190:	80 b7       	in	r24, 0x30	; 48
 192:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:75
  } else
  #endif

  #if defined(TCCR0A) && defined(COM0B1)
  if( timer == TIMER0B){
    cbi(TCCR0A, COM0B1);
 194:	80 bf       	out	0x30, r24	; 48
digitalWrite():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:149

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 196:	f0 e0       	ldi	r31, 0x00	; 0
 198:	ee 0f       	add	r30, r30
 19a:	ff 1f       	adc	r31, r31
 19c:	e2 5d       	subi	r30, 0xD2	; 210
 19e:	ff 4f       	sbci	r31, 0xFF	; 255
 1a0:	a5 91       	lpm	r26, Z+
 1a2:	b4 91       	lpm	r27, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:152

  if (val == LOW) {
    uint8_t oldSREG = SREG;
 1a4:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:151
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 1a6:	61 11       	cpse	r22, r1
 1a8:	17 c0       	rjmp	.+46     	; 0x1d8 <digitalWrite+0x6e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:153
    uint8_t oldSREG = SREG;
    cli();
 1aa:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:154
    *out &= ~bit;
 1ac:	ec 91       	ld	r30, X
 1ae:	20 95       	com	r18
 1b0:	2e 23       	and	r18, r30
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:159
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
 1b2:	2c 93       	st	X, r18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:160
    SREG = oldSREG;
 1b4:	8f bf       	out	0x3f, r24	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:162
  }
}
 1b6:	08 95       	ret
turnOffPWM():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:74
    //cbi(TCCR0A, COM0A0);
  } else
  #endif

  #if defined(TCCR0A) && defined(COM0B1)
  if( timer == TIMER0B){
 1b8:	32 30       	cpi	r19, 0x02	; 2
 1ba:	19 f4       	brne	.+6      	; 0x1c2 <digitalWrite+0x58>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:75
    cbi(TCCR0A, COM0B1);
 1bc:	80 b7       	in	r24, 0x30	; 48
 1be:	8f 7d       	andi	r24, 0xDF	; 223
 1c0:	e9 cf       	rjmp	.-46     	; 0x194 <digitalWrite+0x2a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:82
  } else
  #endif

  #ifndef __AVR_ATtinyX7__
  #if defined(TCCR1A) && defined(COM1A1)
  if( timer == TIMER1A){
 1c2:	33 30       	cpi	r19, 0x03	; 3
 1c4:	21 f4       	brne	.+8      	; 0x1ce <digitalWrite+0x64>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:83
    cbi(TCCR1A, COM1A1);
 1c6:	8f b5       	in	r24, 0x2f	; 47
 1c8:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:114
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1B1)
  if( timer == TIMER1B){
    cbi(TCCR1A, COM1B1);
 1ca:	8f bd       	out	0x2f, r24	; 47
 1cc:	e4 cf       	rjmp	.-56     	; 0x196 <digitalWrite+0x2c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:113
    //cbi(TCCR1, COM1A0);
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1B1)
  if( timer == TIMER1B){
 1ce:	34 30       	cpi	r19, 0x04	; 4
 1d0:	11 f7       	brne	.-60     	; 0x196 <digitalWrite+0x2c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:114
    cbi(TCCR1A, COM1B1);
 1d2:	8f b5       	in	r24, 0x2f	; 47
 1d4:	8f 7d       	andi	r24, 0xDF	; 223
 1d6:	f9 cf       	rjmp	.-14     	; 0x1ca <digitalWrite+0x60>
digitalWrite():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:158
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 1d8:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:159
    *out |= bit;
 1da:	ec 91       	ld	r30, X
 1dc:	2e 2b       	or	r18, r30
 1de:	e9 cf       	rjmp	.-46     	; 0x1b2 <digitalWrite+0x48>

000001e0 <pinMode>:
pinMode():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:33
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 1e0:	cf 93       	push	r28
 1e2:	df 93       	push	r29
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:35
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	fc 01       	movw	r30, r24
 1e8:	e0 5c       	subi	r30, 0xC0	; 192
 1ea:	ff 4f       	sbci	r31, 0xFF	; 255
 1ec:	24 91       	lpm	r18, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 1ee:	8c 5c       	subi	r24, 0xCC	; 204
 1f0:	9f 4f       	sbci	r25, 0xFF	; 255
 1f2:	fc 01       	movw	r30, r24
 1f4:	84 91       	lpm	r24, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 1f6:	88 23       	and	r24, r24
 1f8:	c9 f0       	breq	.+50     	; 0x22c <pinMode+0x4c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 1fa:	90 e0       	ldi	r25, 0x00	; 0
 1fc:	88 0f       	add	r24, r24
 1fe:	99 1f       	adc	r25, r25
 200:	fc 01       	movw	r30, r24
 202:	e8 5d       	subi	r30, 0xD8	; 216
 204:	ff 4f       	sbci	r31, 0xFF	; 255
 206:	a5 91       	lpm	r26, Z+
 208:	b4 91       	lpm	r27, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 20a:	fc 01       	movw	r30, r24
 20c:	e2 5d       	subi	r30, 0xD2	; 210
 20e:	ff 4f       	sbci	r31, 0xFF	; 255
 210:	c5 91       	lpm	r28, Z+
 212:	d4 91       	lpm	r29, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:44

  if (mode == INPUT) {
 214:	61 11       	cpse	r22, r1
 216:	0d c0       	rjmp	.+26     	; 0x232 <pinMode+0x52>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:45
    uint8_t oldSREG = SREG;
 218:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:46
                cli();
 21a:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:47
    *reg &= ~bit;
 21c:	8c 91       	ld	r24, X
 21e:	20 95       	com	r18
 220:	82 23       	and	r24, r18
 222:	8c 93       	st	X, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:48
    *out &= ~bit;
 224:	88 81       	ld	r24, Y
 226:	28 23       	and	r18, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:54
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
                cli();
    *reg &= ~bit;
    *out |= bit;
 228:	28 83       	st	Y, r18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:55
    SREG = oldSREG;
 22a:	9f bf       	out	0x3f, r25	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:62
    uint8_t oldSREG = SREG;
                cli();
    *reg |= bit;
    SREG = oldSREG;
  }
}
 22c:	df 91       	pop	r29
 22e:	cf 91       	pop	r28
 230:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:50
    uint8_t oldSREG = SREG;
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
 232:	62 30       	cpi	r22, 0x02	; 2
 234:	51 f4       	brne	.+20     	; 0x24a <pinMode+0x6a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:51
    uint8_t oldSREG = SREG;
 236:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:52
                cli();
 238:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:53
    *reg &= ~bit;
 23a:	3c 91       	ld	r19, X
 23c:	82 2f       	mov	r24, r18
 23e:	80 95       	com	r24
 240:	83 23       	and	r24, r19
 242:	8c 93       	st	X, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:54
    *out |= bit;
 244:	e8 81       	ld	r30, Y
 246:	2e 2b       	or	r18, r30
 248:	ef cf       	rjmp	.-34     	; 0x228 <pinMode+0x48>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:57
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 24a:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:58
                cli();
 24c:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 24e:	ec 91       	ld	r30, X
 250:	2e 2b       	or	r18, r30
 252:	2c 93       	st	X, r18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 254:	8f bf       	out	0x3f, r24	; 63
 256:	ea cf       	rjmp	.-44     	; 0x22c <pinMode+0x4c>

00000258 <micros>:
micros():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:181
  }

  unsigned long micros()
  {
    unsigned long m;
    uint8_t oldSREG = SREG, t;
 258:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:183

    cli();
 25a:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:184
    m = millis_timer_overflow_count;
 25c:	80 91 e5 00 	lds	r24, 0x00E5	; 0x8000e5 <millis_timer_overflow_count>
 260:	90 91 e6 00 	lds	r25, 0x00E6	; 0x8000e6 <millis_timer_overflow_count+0x1>
 264:	a0 91 e7 00 	lds	r26, 0x00E7	; 0x8000e7 <millis_timer_overflow_count+0x2>
 268:	b0 91 e8 00 	lds	r27, 0x00E8	; 0x8000e8 <millis_timer_overflow_count+0x3>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:186
  #if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
    t = TCNT0;
 26c:	22 b7       	in	r18, 0x32	; 50
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:198
  #else
    #error "Millis()/Micros() timer not defined"
  #endif

  #if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
    if ((TIFR0 & _BV(TOV0)) && (t < 255))
 26e:	08 b6       	in	r0, 0x38	; 56
 270:	00 fe       	sbrs	r0, 0
 272:	05 c0       	rjmp	.+10     	; 0x27e <__stack+0x1f>
 274:	2f 3f       	cpi	r18, 0xFF	; 255
 276:	19 f0       	breq	.+6      	; 0x27e <__stack+0x1f>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:199
      m++;
 278:	01 96       	adiw	r24, 0x01	; 1
 27a:	a1 1d       	adc	r26, r1
 27c:	b1 1d       	adc	r27, r1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:211
  #elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
    if ((TIFR & _BV(TOV1)) && (t < 255))
      m++;
  #endif

    SREG = oldSREG;
 27e:	3f bf       	out	0x3f, r19	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:218

  #if F_CPU < 1000000L
    return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
  #else
    #if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 && (F_CPU % 1000000 == 0 )) // Can we just do it the naive way? If so great!
      return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 280:	ba 2f       	mov	r27, r26
 282:	a9 2f       	mov	r26, r25
 284:	98 2f       	mov	r25, r24
 286:	88 27       	eor	r24, r24
 288:	bc 01       	movw	r22, r24
 28a:	cd 01       	movw	r24, r26
 28c:	62 0f       	add	r22, r18
 28e:	71 1d       	adc	r23, r1
 290:	81 1d       	adc	r24, r1
 292:	91 1d       	adc	r25, r1
 294:	43 e0       	ldi	r20, 0x03	; 3
 296:	66 0f       	add	r22, r22
 298:	77 1f       	adc	r23, r23
 29a:	88 1f       	adc	r24, r24
 29c:	99 1f       	adc	r25, r25
 29e:	4a 95       	dec	r20
 2a0:	d1 f7       	brne	.-12     	; 0x296 <__stack+0x37>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:266
      //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
      //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
      return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
    #endif
  #endif
  }
 2a2:	08 95       	ret

000002a4 <delay.constprop.0>:
delay.constprop.0():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:275
  static void __empty() {
    // Empty
  }
  void yield(void) __attribute__ ((weak, alias("__empty")));

  void delay(unsigned long ms)
 2a4:	cf 92       	push	r12
 2a6:	df 92       	push	r13
 2a8:	ef 92       	push	r14
 2aa:	ff 92       	push	r15
 2ac:	cf 93       	push	r28
 2ae:	df 93       	push	r29
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:278
  {
    #if (F_CPU>=1000000L)
    uint16_t start = (uint16_t)micros();
 2b0:	d3 df       	rcall	.-90     	; 0x258 <micros>
 2b2:	eb 01       	movw	r28, r22
 2b4:	8b e0       	ldi	r24, 0x0B	; 11
 2b6:	c8 2e       	mov	r12, r24
 2b8:	d1 2c       	mov	r13, r1
 2ba:	e1 2c       	mov	r14, r1
 2bc:	f1 2c       	mov	r15, r1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:282

    while (ms > 0) {
      yield();
      while (((uint16_t)micros() - start) >= 1000 && ms) {
 2be:	cc df       	rcall	.-104    	; 0x258 <micros>
 2c0:	6c 1b       	sub	r22, r28
 2c2:	7d 0b       	sbc	r23, r29
 2c4:	68 3e       	cpi	r22, 0xE8	; 232
 2c6:	73 40       	sbci	r23, 0x03	; 3
 2c8:	a0 f0       	brcs	.+40     	; 0x2f2 <delay.constprop.0+0x4e>
 2ca:	c1 14       	cp	r12, r1
 2cc:	d1 04       	cpc	r13, r1
 2ce:	e1 04       	cpc	r14, r1
 2d0:	f1 04       	cpc	r15, r1
 2d2:	39 f4       	brne	.+14     	; 0x2e2 <delay.constprop.0+0x3e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:292
    #else
    uint32_t start = millis();
    while((millis() - start) < ms)  /* NOP */yield();
    return;
    #endif
  }
 2d4:	df 91       	pop	r29
 2d6:	cf 91       	pop	r28
 2d8:	ff 90       	pop	r15
 2da:	ef 90       	pop	r14
 2dc:	df 90       	pop	r13
 2de:	cf 90       	pop	r12
 2e0:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:283
    uint16_t start = (uint16_t)micros();

    while (ms > 0) {
      yield();
      while (((uint16_t)micros() - start) >= 1000 && ms) {
        ms--;
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	c8 1a       	sub	r12, r24
 2e6:	d1 08       	sbc	r13, r1
 2e8:	e1 08       	sbc	r14, r1
 2ea:	f1 08       	sbc	r15, r1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:284
        start += 1000;
 2ec:	c8 51       	subi	r28, 0x18	; 24
 2ee:	dc 4f       	sbci	r29, 0xFC	; 252
 2f0:	e6 cf       	rjmp	.-52     	; 0x2be <delay.constprop.0+0x1a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:280
  void delay(unsigned long ms)
  {
    #if (F_CPU>=1000000L)
    uint16_t start = (uint16_t)micros();

    while (ms > 0) {
 2f2:	c1 14       	cp	r12, r1
 2f4:	d1 04       	cpc	r13, r1
 2f6:	e1 04       	cpc	r14, r1
 2f8:	f1 04       	cpc	r15, r1
 2fa:	09 f7       	brne	.-62     	; 0x2be <delay.constprop.0+0x1a>
 2fc:	eb cf       	rjmp	.-42     	; 0x2d4 <delay.constprop.0+0x30>

000002fe <SoftwareSerial::peek()>:
_ZN14SoftwareSerial4peekEv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:481
  SREG = oldSREG;
}

int SoftwareSerial::peek()
{
  if (!isListening())
 2fe:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 302:	30 91 ec 00 	lds	r19, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 306:	28 17       	cp	r18, r24
 308:	39 07       	cpc	r19, r25
 30a:	81 f4       	brne	.+32     	; 0x32c <SoftwareSerial::peek()+0x2e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:485
    return -1;

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
 30c:	90 91 e9 00 	lds	r25, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 310:	80 91 ea 00 	lds	r24, 0x00EA	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 314:	98 17       	cp	r25, r24
 316:	51 f0       	breq	.+20     	; 0x32c <SoftwareSerial::peek()+0x2e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:489
    return -1;

  // Read from "head"
  return _receive_buffer[_receive_buffer_head];
 318:	e0 91 e9 00 	lds	r30, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 31c:	f0 e0       	ldi	r31, 0x00	; 0
 31e:	ec 55       	subi	r30, 0x5C	; 92
 320:	ff 4f       	sbci	r31, 0xFF	; 255
 322:	80 81       	ld	r24, Z
 324:	08 2e       	mov	r0, r24
 326:	00 0c       	add	r0, r0
 328:	99 0b       	sbc	r25, r25
 32a:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:482
}

int SoftwareSerial::peek()
{
  if (!isListening())
    return -1;
 32c:	8f ef       	ldi	r24, 0xFF	; 255
 32e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:490
  if (_receive_buffer_head == _receive_buffer_tail)
    return -1;

  // Read from "head"
  return _receive_buffer[_receive_buffer_head];
}
 330:	08 95       	ret

00000332 <SoftwareSerial::flush()>:
_ZN14SoftwareSerial5flushEv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:470
  return 1;
}

void SoftwareSerial::flush()
{
  if (!isListening())
 332:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 336:	30 91 ec 00 	lds	r19, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 33a:	28 17       	cp	r18, r24
 33c:	39 07       	cpc	r19, r25
 33e:	39 f4       	brne	.+14     	; 0x34e <SoftwareSerial::flush()+0x1c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:473
    return;

  uint8_t oldSREG = SREG;
 340:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:474
  cli();
 342:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:475
  _receive_buffer_head = _receive_buffer_tail = 0;
 344:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 348:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:476
  SREG = oldSREG;
 34c:	8f bf       	out	0x3f, r24	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:477
}
 34e:	08 95       	ret

00000350 <SoftwareSerial::write(unsigned char)>:
_ZN14SoftwareSerial5writeEh():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:414

  return (_receive_buffer_tail + _SS_MAX_RX_BUFF - _receive_buffer_head) % _SS_MAX_RX_BUFF;
}

size_t SoftwareSerial::write(uint8_t b)
{
 350:	ef 92       	push	r14
 352:	ff 92       	push	r15
 354:	0f 93       	push	r16
 356:	1f 93       	push	r17
 358:	cf 93       	push	r28
 35a:	df 93       	push	r29
 35c:	dc 01       	movw	r26, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:415
  if (_tx_delay == 0) {
 35e:	5c 96       	adiw	r26, 0x1c	; 28
 360:	ed 90       	ld	r14, X+
 362:	fc 90       	ld	r15, X
 364:	5d 97       	sbiw	r26, 0x1d	; 29
 366:	e1 14       	cp	r14, r1
 368:	f1 04       	cpc	r15, r1
 36a:	79 f4       	brne	.+30     	; 0x38a <SoftwareSerial::write(unsigned char)+0x3a>
_ZN5Print13setWriteErrorEi():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.h:73
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
 36c:	81 e0       	ldi	r24, 0x01	; 1
 36e:	90 e0       	ldi	r25, 0x00	; 0
 370:	13 96       	adiw	r26, 0x03	; 3
 372:	9c 93       	st	X, r25
 374:	8e 93       	st	-X, r24
 376:	12 97       	sbiw	r26, 0x02	; 2
_ZN14SoftwareSerial5writeEh():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:417
    setWriteError();
    return 0;
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:466

  SREG = oldSREG; // turn interrupts back on
  tunedDelay(_tx_delay);

  return 1;
}
 37c:	df 91       	pop	r29
 37e:	cf 91       	pop	r28
 380:	1f 91       	pop	r17
 382:	0f 91       	pop	r16
 384:	ff 90       	pop	r15
 386:	ef 90       	pop	r14
 388:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:424

  // By declaring these as local variables, the compiler will put them
  // in registers _before_ disabling interrupts and entering the
  // critical timing sections below, which makes it a lot easier to
  // verify the cycle timings
  volatile uint8_t *reg = _transmitPortRegister;
 38a:	51 96       	adiw	r26, 0x11	; 17
 38c:	ed 91       	ld	r30, X+
 38e:	fc 91       	ld	r31, X
 390:	52 97       	sbiw	r26, 0x12	; 18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:425
  uint8_t reg_mask = _transmitBitMask;
 392:	50 96       	adiw	r26, 0x10	; 16
 394:	8c 91       	ld	r24, X
 396:	50 97       	sbiw	r26, 0x10	; 16
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:426
  uint8_t inv_mask = ~_transmitBitMask;
 398:	98 2f       	mov	r25, r24
 39a:	90 95       	com	r25
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:427
  uint8_t oldSREG = SREG;
 39c:	0f b7       	in	r16, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:428
  bool inv = _inverse_logic;
 39e:	5e 96       	adiw	r26, 0x1e	; 30
 3a0:	2c 91       	ld	r18, X
 3a2:	5e 97       	sbiw	r26, 0x1e	; 30
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:431
  uint16_t delay = _tx_delay;

  if (inv)
 3a4:	12 2f       	mov	r17, r18
 3a6:	12 70       	andi	r17, 0x02	; 2
 3a8:	21 fd       	sbrc	r18, 1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:432
    b = ~b;
 3aa:	60 95       	com	r22
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:434

  cli();  // turn off interrupts for a clean txmit
 3ac:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:438

  // Write the start bit
  if (inv)
    *reg |= reg_mask;
 3ae:	20 81       	ld	r18, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:437
    b = ~b;

  cli();  // turn off interrupts for a clean txmit

  // Write the start bit
  if (inv)
 3b0:	11 23       	and	r17, r17
 3b2:	19 f1       	breq	.+70     	; 0x3fa <SoftwareSerial::write(unsigned char)+0xaa>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:438
    *reg |= reg_mask;
 3b4:	28 2b       	or	r18, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:440
  else
    *reg &= inv_mask;
 3b6:	20 83       	st	Z, r18
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
 3b8:	e7 01       	movw	r28, r14
 3ba:	21 97       	sbiw	r28, 0x01	; 1
 3bc:	f1 f7       	brne	.-4      	; 0x3ba <SoftwareSerial::write(unsigned char)+0x6a>
 3be:	28 e0       	ldi	r18, 0x08	; 8
_ZN14SoftwareSerial5writeEh():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:447
  tunedDelay(delay);

  // Write each of the 8 bits
  for (uint8_t i = 8; i > 0; --i)
  {
    if (b & 1) // choose bit
 3c0:	46 2f       	mov	r20, r22
 3c2:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:448
      *reg |= reg_mask; // send 1
 3c4:	30 81       	ld	r19, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:447
  tunedDelay(delay);

  // Write each of the 8 bits
  for (uint8_t i = 8; i > 0; --i)
  {
    if (b & 1) // choose bit
 3c6:	60 ff       	sbrs	r22, 0
 3c8:	1a c0       	rjmp	.+52     	; 0x3fe <SoftwareSerial::write(unsigned char)+0xae>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:448
      *reg |= reg_mask; // send 1
 3ca:	38 2b       	or	r19, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:450
    else
      *reg &= inv_mask; // send 0
 3cc:	30 83       	st	Z, r19
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
 3ce:	e7 01       	movw	r28, r14
 3d0:	21 97       	sbiw	r28, 0x01	; 1
 3d2:	f1 f7       	brne	.-4      	; 0x3d0 <SoftwareSerial::write(unsigned char)+0x80>
_ZN14SoftwareSerial5writeEh():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:453

    tunedDelay(delay);
    b >>= 1;
 3d4:	ba 01       	movw	r22, r20
 3d6:	75 95       	asr	r23
 3d8:	67 95       	ror	r22
 3da:	21 50       	subi	r18, 0x01	; 1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:445
    *reg &= inv_mask;

  tunedDelay(delay);

  // Write each of the 8 bits
  for (uint8_t i = 8; i > 0; --i)
 3dc:	89 f7       	brne	.-30     	; 0x3c0 <SoftwareSerial::write(unsigned char)+0x70>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:457
    tunedDelay(delay);
    b >>= 1;
  }

  // restore pin to natural state
  if (inv)
 3de:	11 23       	and	r17, r17
 3e0:	81 f0       	breq	.+32     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:458
    *reg &= inv_mask;
 3e2:	80 81       	ld	r24, Z
 3e4:	89 23       	and	r24, r25
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:460
  else
    *reg |= reg_mask;
 3e6:	80 83       	st	Z, r24
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:462

  SREG = oldSREG; // turn interrupts back on
 3e8:	0f bf       	out	0x3f, r16	; 63
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
 3ea:	5c 96       	adiw	r26, 0x1c	; 28
 3ec:	8d 91       	ld	r24, X+
 3ee:	9c 91       	ld	r25, X
 3f0:	01 97       	sbiw	r24, 0x01	; 1
 3f2:	f1 f7       	brne	.-4      	; 0x3f0 <SoftwareSerial::write(unsigned char)+0xa0>
_ZN14SoftwareSerial5writeEh():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:465
  tunedDelay(_tx_delay);

  return 1;
 3f4:	81 e0       	ldi	r24, 0x01	; 1
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	c1 cf       	rjmp	.-126    	; 0x37c <SoftwareSerial::write(unsigned char)+0x2c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:440

  // Write the start bit
  if (inv)
    *reg |= reg_mask;
  else
    *reg &= inv_mask;
 3fa:	29 23       	and	r18, r25
 3fc:	dc cf       	rjmp	.-72     	; 0x3b6 <SoftwareSerial::write(unsigned char)+0x66>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:450
  for (uint8_t i = 8; i > 0; --i)
  {
    if (b & 1) // choose bit
      *reg |= reg_mask; // send 1
    else
      *reg &= inv_mask; // send 0
 3fe:	39 23       	and	r19, r25
 400:	e5 cf       	rjmp	.-54     	; 0x3cc <SoftwareSerial::write(unsigned char)+0x7c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:460

  // restore pin to natural state
  if (inv)
    *reg &= inv_mask;
  else
    *reg |= reg_mask;
 402:	90 81       	ld	r25, Z
 404:	89 2b       	or	r24, r25
 406:	ef cf       	rjmp	.-34     	; 0x3e6 <SoftwareSerial::write(unsigned char)+0x96>

00000408 <SoftwareSerial::available()>:
_ZN14SoftwareSerial9availableEv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:407
  return d;
}

int SoftwareSerial::available()
{
  if (!isListening())
 408:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 40c:	30 91 ec 00 	lds	r19, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 410:	28 17       	cp	r18, r24
 412:	39 07       	cpc	r19, r25
 414:	69 f4       	brne	.+26     	; 0x430 <SoftwareSerial::available()+0x28>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:410
    return 0;

  return (_receive_buffer_tail + _SS_MAX_RX_BUFF - _receive_buffer_head) % _SS_MAX_RX_BUFF;
 416:	80 91 ea 00 	lds	r24, 0x00EA	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 41a:	20 91 e9 00 	lds	r18, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 41e:	90 e0       	ldi	r25, 0x00	; 0
 420:	80 5c       	subi	r24, 0xC0	; 192
 422:	9f 4f       	sbci	r25, 0xFF	; 255
 424:	82 1b       	sub	r24, r18
 426:	91 09       	sbc	r25, r1
 428:	60 e4       	ldi	r22, 0x40	; 64
 42a:	70 e0       	ldi	r23, 0x00	; 0
 42c:	0b d5       	rcall	.+2582   	; 0xe44 <__divmodhi4>
 42e:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:408
}

int SoftwareSerial::available()
{
  if (!isListening())
    return 0;
 430:	90 e0       	ldi	r25, 0x00	; 0
 432:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:411

  return (_receive_buffer_tail + _SS_MAX_RX_BUFF - _receive_buffer_head) % _SS_MAX_RX_BUFF;
}
 434:	08 95       	ret

00000436 <SoftwareSerial::read()>:
_ZN14SoftwareSerial4readEv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:392


// Read data from buffer
int SoftwareSerial::read()
{
  if (!isListening())
 436:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 43a:	30 91 ec 00 	lds	r19, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 43e:	28 17       	cp	r18, r24
 440:	39 07       	cpc	r19, r25
 442:	b9 f4       	brne	.+46     	; 0x472 <SoftwareSerial::read()+0x3c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:396
    return -1;

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
 444:	90 91 e9 00 	lds	r25, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 448:	80 91 ea 00 	lds	r24, 0x00EA	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 44c:	98 17       	cp	r25, r24
 44e:	89 f0       	breq	.+34     	; 0x472 <SoftwareSerial::read()+0x3c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:400
    return -1;

  // Read from "head"
  uint8_t d = _receive_buffer[_receive_buffer_head]; // grab next byte
 450:	e0 91 e9 00 	lds	r30, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 454:	f0 e0       	ldi	r31, 0x00	; 0
 456:	ec 55       	subi	r30, 0x5C	; 92
 458:	ff 4f       	sbci	r31, 0xFF	; 255
 45a:	80 81       	ld	r24, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:401
  _receive_buffer_head = (_receive_buffer_head + 1) % _SS_MAX_RX_BUFF;
 45c:	20 91 e9 00 	lds	r18, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 460:	30 e0       	ldi	r19, 0x00	; 0
 462:	2f 5f       	subi	r18, 0xFF	; 255
 464:	3f 4f       	sbci	r19, 0xFF	; 255
 466:	2f 73       	andi	r18, 0x3F	; 63
 468:	33 27       	eor	r19, r19
 46a:	20 93 e9 00 	sts	0x00E9, r18	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:402
  return d;
 46e:	90 e0       	ldi	r25, 0x00	; 0
 470:	08 95       	ret
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:393

// Read data from buffer
int SoftwareSerial::read()
{
  if (!isListening())
    return -1;
 472:	8f ef       	ldi	r24, 0xFF	; 255
 474:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:403

  // Read from "head"
  uint8_t d = _receive_buffer[_receive_buffer_head]; // grab next byte
  _receive_buffer_head = (_receive_buffer_head + 1) % _SS_MAX_RX_BUFF;
  return d;
}
 476:	08 95       	ret

00000478 <USI_TWI_Slave_Initialise>:
USI_TWI_Slave_Initialise():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:54
static volatile uint8_t TWI_TxHead;
static volatile uint8_t TWI_TxTail;

void Flush_TWI_Buffers(void)
{
  TWI_RxTail = 0;
 478:	10 92 f1 01 	sts	0x01F1, r1	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:55
  TWI_RxHead = 0;
 47c:	10 92 f0 01 	sts	0x01F0, r1	; 0x8001f0 <TWI_RxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:56
  TWI_TxTail = 0;
 480:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <TWI_TxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:57
  TWI_TxHead = 0;
 484:	10 92 9f 00 	sts	0x009F, r1	; 0x80009f <TWI_TxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:69
----------------------------------------------------------*/
void USI_TWI_Slave_Initialise(unsigned char TWI_ownAddress)
{
  Flush_TWI_Buffers();

  TWI_slaveAddress = TWI_ownAddress;
 488:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <TWI_slaveAddress>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:71

  USI_TWI_On_Slave_Transmit = 0;
 48c:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <USI_TWI_On_Slave_Transmit+0x1>
 490:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <USI_TWI_On_Slave_Transmit>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:72
  USI_TWI_On_Slave_Receive = 0;
 494:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <USI_TWI_On_Slave_Receive+0x1>
 498:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <USI_TWI_On_Slave_Receive>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:74

  PORT_USI_CL |= (1 << PORT_USI_SCL);     // Set SCL high
 49c:	dc 9a       	sbi	0x1b, 4	; 27
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:75
  PORT_USI |= (1 << PORT_USI_SDA);        // Set SDA high
 49e:	de 9a       	sbi	0x1b, 6	; 27
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:76
  DDR_USI_CL |= (1 << PORT_USI_SCL);      // Set SCL as output
 4a0:	d4 9a       	sbi	0x1a, 4	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:77
  DDR_USI &= ~(1 << PORT_USI_SDA);        // Set SDA as input
 4a2:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:78
  USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 4a4:	88 ea       	ldi	r24, 0xA8	; 168
 4a6:	8d b9       	out	0x0d, r24	; 13
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:83
          (1 << USIWM1) | (0 << USIWM0) | // Set USI in Two-wire mode. No USI Counter overflow prior
                                          // to first Start Condition (potential failure)
          (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
          (0 << USITC);
  USISR = 0xF0; // Clear all flags and reset overflow counter
 4a8:	80 ef       	ldi	r24, 0xF0	; 240
 4aa:	8e b9       	out	0x0e, r24	; 14
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:84
}
 4ac:	08 95       	ret

000004ae <startI2C()>:
_Z8startI2Cv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:89

// Disable USI for TWI Slave mode.
void USI_TWI_Slave_Disable()
{
  DDR_USI_CL &= ~(1 << PORT_USI_SCL);  // Set SCL as input
 4ae:	d4 98       	cbi	0x1a, 4	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:90
  DDR_USI &= ~(1 << PORT_USI_SDA);  // Set SDA as input
 4b0:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:91
  USICR = 0x00; // Disable USI
 4b2:	1d b8       	out	0x0d, r1	; 13
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:92
  USISR = 0xF0; // Clear all flags and reset overflow counter
 4b4:	80 ef       	ldi	r24, 0xF0	; 240
 4b6:	8e b9       	out	0x0e, r24	; 14
digitalRead():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:168

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  //uint8_t timer = digitalPinToTimer(pin);
  uint8_t bit = digitalPinToBitMask(pin);
 4b8:	e0 e4       	ldi	r30, 0x40	; 64
 4ba:	f0 e0       	ldi	r31, 0x00	; 0
 4bc:	84 91       	lpm	r24, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:169
  uint8_t port = digitalPinToPort(pin);
 4be:	e4 e3       	ldi	r30, 0x34	; 52
 4c0:	f0 e0       	ldi	r31, 0x00	; 0
 4c2:	e4 91       	lpm	r30, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:171

  if (port == NOT_A_PIN) return LOW;
 4c4:	ee 23       	and	r30, r30
 4c6:	f1 f0       	breq	.+60     	; 0x504 <startI2C()+0x56>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring_digital.c:179
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
 4c8:	f0 e0       	ldi	r31, 0x00	; 0
 4ca:	ee 0f       	add	r30, r30
 4cc:	ff 1f       	adc	r31, r31
 4ce:	ee 5d       	subi	r30, 0xDE	; 222
 4d0:	ff 4f       	sbci	r31, 0xFF	; 255
 4d2:	a5 91       	lpm	r26, Z+
 4d4:	b4 91       	lpm	r27, Z
 4d6:	ec 91       	ld	r30, X
 4d8:	e8 23       	and	r30, r24
 4da:	a1 f0       	breq	.+40     	; 0x504 <startI2C()+0x56>
_Z8startI2Cv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:259
void startI2C()
{
  Wire.end(); //Before we can change addresses we need to stop
  
  if (digitalRead(addrPin) == HIGH) //Default is HIGH, the jumper is closed with paste in production
    Wire.begin(setting_i2c_address); //Start I2C and answer calls using address from EEPROM
 4dc:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <setting_i2c_address>
begin():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:371

  USI_TWI_Master_Initialise();
}

void TwoWire::begin(uint8_t address) {
  BufferIndex = 0;
 4e0:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <TwoWire::BufferIndex>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:372
  BufferLength = 0;
 4e4:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <TwoWire::BufferLength>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:374

  USI_TWI_Slave_Initialise(address);
 4e8:	c7 df       	rcall	.-114    	; 0x478 <USI_TWI_Slave_Initialise>
onReceive():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:594
  // XXX: to be implemented.
}

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) ) {
  USI_TWI_On_Slave_Receive = function;
 4ea:	8d e0       	ldi	r24, 0x0D	; 13
 4ec:	93 e0       	ldi	r25, 0x03	; 3
 4ee:	90 93 9d 00 	sts	0x009D, r25	; 0x80009d <USI_TWI_On_Slave_Receive+0x1>
 4f2:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <USI_TWI_On_Slave_Receive>
onRequest():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:599
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) ) {
  USI_TWI_On_Slave_Transmit = function;
 4f6:	88 e8       	ldi	r24, 0x88	; 136
 4f8:	92 e0       	ldi	r25, 0x02	; 2
 4fa:	90 93 a1 00 	sts	0x00A1, r25	; 0x8000a1 <USI_TWI_On_Slave_Transmit+0x1>
 4fe:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <USI_TWI_On_Slave_Transmit>
_Z8startI2Cv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:266
    Wire.begin(I2C_ADDRESS_NO_JUMPER); //Force address to I2C_ADDRESS_NO_JUMPER if user has opened the solder jumper

  //The connections to the interrupts are severed when a Wire.begin occurs. So re-declare them.
  Wire.onReceive(receiveEvent);
  Wire.onRequest(requestEvent);
}
 502:	08 95       	ret
begin():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:371

  USI_TWI_Master_Initialise();
}

void TwoWire::begin(uint8_t address) {
  BufferIndex = 0;
 504:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <TwoWire::BufferIndex>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:372
  BufferLength = 0;
 508:	10 92 f3 01 	sts	0x01F3, r1	; 0x8001f3 <TwoWire::BufferLength>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:374

  USI_TWI_Slave_Initialise(address);
 50c:	84 e1       	ldi	r24, 0x14	; 20
 50e:	ec cf       	rjmp	.-40     	; 0x4e8 <startI2C()+0x3a>

00000510 <requestEvent()>:
_Z12requestEventv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:203
}

//Send back a number of bytes via an array, max is 8 bytes at a time, 6 byte TAG ID and 2 byte time stamp.
//When the RFID module gets a request for data from the user, this function is called as an interrupt.
void requestEvent()
{
 510:	0f 93       	push	r16
 512:	1f 93       	push	r17
loadNextTagToArray():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:212
}

//Take the FIFO button press off the stack and load it into the transmit array
void loadNextTagToArray()
{
  if (oldestTag != newestTag)
 514:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <oldestTag>
 518:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <newestTag>
 51c:	a2 e9       	ldi	r26, 0x92	; 146
 51e:	b0 e0       	ldi	r27, 0x00	; 0
_Z12requestEventv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:214
  {
		for( int i = 0; i < 6; i ++ )
 520:	30 e0       	ldi	r19, 0x00	; 0
 522:	20 e0       	ldi	r18, 0x00	; 0
loadNextTagToArray():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:212
}

//Take the FIFO button press off the stack and load it into the transmit array
void loadNextTagToArray()
{
  if (oldestTag != newestTag)
 524:	98 13       	cpse	r25, r24
 526:	34 c0       	rjmp	.+104    	; 0x590 <requestEvent()+0x80>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:230
  else
  {
    //No new ID's. 
		for( int i = 0; i < 8; i++ )
		{
			responseBuffer[i] = 0; 
 528:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <responseBuffer>
 52c:	10 92 93 00 	sts	0x0093, r1	; 0x800093 <responseBuffer+0x1>
 530:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <responseBuffer+0x2>
 534:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <responseBuffer+0x3>
 538:	10 92 96 00 	sts	0x0096, r1	; 0x800096 <responseBuffer+0x4>
 53c:	10 92 97 00 	sts	0x0097, r1	; 0x800097 <responseBuffer+0x5>
 540:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <responseBuffer+0x6>
 544:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <responseBuffer+0x7>
_Z12requestEventv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:214
//Take the FIFO button press off the stack and load it into the transmit array
void loadNextTagToArray()
{
  if (oldestTag != newestTag)
  {
		for( int i = 0; i < 6; i ++ )
 548:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:205
//Send back a number of bytes via an array, max is 8 bytes at a time, 6 byte TAG ID and 2 byte time stamp.
//When the RFID module gets a request for data from the user, this function is called as an interrupt.
void requestEvent()
{
  loadNextTagToArray(); //Send response buffer
  for (byte x = 0 ; x < responseSize ; x++)
 54a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 54e:	98 17       	cp	r25, r24
 550:	08 f0       	brcs	.+2      	; 0x554 <requestEvent()+0x44>
 552:	60 c0       	rjmp	.+192    	; 0x614 <requestEvent()+0x104>
USI_TWI_Space_In_Transmission_Buffer():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 554:	20 91 9f 00 	lds	r18, 0x009F	; 0x80009f <TWI_TxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 558:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <TWI_TxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 55c:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 55e:	82 1b       	sub	r24, r18
 560:	8f 70       	andi	r24, 0x0F	; 15
write():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src/Wire.cpp:513
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
 562:	a1 f0       	breq	.+40     	; 0x58c <requestEvent()+0x7c>
USI_TWI_Transmit_Byte():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
 564:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <TWI_TxHead>
 568:	8f 5f       	subi	r24, 0xFF	; 255
 56a:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
 56c:	20 91 9e 00 	lds	r18, 0x009E	; 0x80009e <TWI_TxTail>
 570:	82 17       	cp	r24, r18
 572:	e1 f3       	breq	.-8      	; 0x56c <requestEvent()+0x5c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 574:	e8 2f       	mov	r30, r24
 576:	f0 e0       	ldi	r31, 0x00	; 0
 578:	ee 57       	subi	r30, 0x7E	; 126
 57a:	ff 4f       	sbci	r31, 0xFF	; 255
_Z12requestEventv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:206
    Wire.write(responseBuffer[x]);
 57c:	a9 2f       	mov	r26, r25
 57e:	b0 e0       	ldi	r27, 0x00	; 0
 580:	ae 56       	subi	r26, 0x6E	; 110
 582:	bf 4f       	sbci	r27, 0xFF	; 255
USI_TWI_Transmit_Byte():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
 584:	2c 91       	ld	r18, X
 586:	20 83       	st	Z, r18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
 588:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <TWI_TxHead>
_Z12requestEventv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:205
//Send back a number of bytes via an array, max is 8 bytes at a time, 6 byte TAG ID and 2 byte time stamp.
//When the RFID module gets a request for data from the user, this function is called as an interrupt.
void requestEvent()
{
  loadNextTagToArray(); //Send response buffer
  for (byte x = 0 ; x < responseSize ; x++)
 58c:	9f 5f       	subi	r25, 0xFF	; 255
 58e:	dd cf       	rjmp	.-70     	; 0x54a <requestEvent()+0x3a>
loadNextTagToArray():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:216
{
  if (oldestTag != newestTag)
  {
		for( int i = 0; i < 6; i ++ )
		{
			responseBuffer[i] = tagEvent[oldestTag].tagID[i];
 590:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <oldestTag>
 594:	90 e0       	ldi	r25, 0x00	; 0
 596:	6a e0       	ldi	r22, 0x0A	; 10
 598:	70 e0       	ldi	r23, 0x00	; 0
 59a:	43 d4       	rcall	.+2182   	; 0xe22 <__mulhi3>
 59c:	88 5f       	subi	r24, 0xF8	; 248
 59e:	9e 4f       	sbci	r25, 0xFE	; 254
 5a0:	fc 01       	movw	r30, r24
 5a2:	e2 0f       	add	r30, r18
 5a4:	f3 1f       	adc	r31, r19
 5a6:	80 81       	ld	r24, Z
 5a8:	8d 93       	st	X+, r24
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:214
//Take the FIFO button press off the stack and load it into the transmit array
void loadNextTagToArray()
{
  if (oldestTag != newestTag)
  {
		for( int i = 0; i < 6; i ++ )
 5aa:	2f 5f       	subi	r18, 0xFF	; 255
 5ac:	3f 4f       	sbci	r19, 0xFF	; 255
 5ae:	26 30       	cpi	r18, 0x06	; 6
 5b0:	31 05       	cpc	r19, r1
 5b2:	71 f7       	brne	.-36     	; 0x590 <requestEvent()+0x80>
millis():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:167
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 5b4:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:171

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 5b6:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:172
    m = millis_timer_millis;
 5b8:	00 91 03 01 	lds	r16, 0x0103	; 0x800103 <millis_timer_millis>
 5bc:	10 91 04 01 	lds	r17, 0x0104	; 0x800104 <millis_timer_millis+0x1>
 5c0:	20 91 05 01 	lds	r18, 0x0105	; 0x800105 <millis_timer_millis+0x2>
 5c4:	30 91 06 01 	lds	r19, 0x0106	; 0x800106 <millis_timer_millis+0x3>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:173
    SREG = oldSREG;
 5c8:	8f bf       	out	0x3f, r24	; 63
loadNextTagToArray():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:218
		{
			responseBuffer[i] = tagEvent[oldestTag].tagID[i];
		}
    unsigned long timeSincePressed = millis() - tagEvent[oldestTag].tagTime;//This is the time since last scan.
 5ca:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <oldestTag>
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	6a e0       	ldi	r22, 0x0A	; 10
 5d2:	70 e0       	ldi	r23, 0x00	; 0
 5d4:	26 d4       	rcall	.+2124   	; 0xe22 <__mulhi3>
 5d6:	88 5f       	subi	r24, 0xF8	; 248
 5d8:	9e 4f       	sbci	r25, 0xFE	; 254
 5da:	fc 01       	movw	r30, r24
 5dc:	86 81       	ldd	r24, Z+6	; 0x06
 5de:	97 81       	ldd	r25, Z+7	; 0x07
 5e0:	a0 85       	ldd	r26, Z+8	; 0x08
 5e2:	b1 85       	ldd	r27, Z+9	; 0x09
 5e4:	08 1b       	sub	r16, r24
 5e6:	19 0b       	sbc	r17, r25
 5e8:	2a 0b       	sbc	r18, r26
 5ea:	3b 0b       	sbc	r19, r27
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:219
    responseBuffer[6] = timeSincePressed >> 24; //MSB
 5ec:	30 93 98 00 	sts	0x0098, r19	; 0x800098 <responseBuffer+0x6>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:220
    responseBuffer[7] = timeSincePressed >> 16; 
 5f0:	20 93 99 00 	sts	0x0099, r18	; 0x800099 <responseBuffer+0x7>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:221
    responseBuffer[8] = timeSincePressed >> 8;
 5f4:	10 93 9a 00 	sts	0x009A, r17	; 0x80009a <responseBuffer+0x8>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:222
    responseBuffer[9] = timeSincePressed; //LSB
 5f8:	00 93 9b 00 	sts	0x009B, r16	; 0x80009b <responseBuffer+0x9>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:223
    if (oldestTag++ == MAX_TAG_STORAGE) oldestTag = 0;
 5fc:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <oldestTag>
 600:	91 e0       	ldi	r25, 0x01	; 1
 602:	98 0f       	add	r25, r24
 604:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <oldestTag>
 608:	84 31       	cpi	r24, 0x14	; 20
 60a:	09 f0       	breq	.+2      	; 0x60e <requestEvent()+0xfe>
 60c:	9d cf       	rjmp	.-198    	; 0x548 <requestEvent()+0x38>
 60e:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <oldestTag>
 612:	9a cf       	rjmp	.-204    	; 0x548 <requestEvent()+0x38>
_Z12requestEventv():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:207
void requestEvent()
{
  loadNextTagToArray(); //Send response buffer
  for (byte x = 0 ; x < responseSize ; x++)
    Wire.write(responseBuffer[x]);
}
 614:	1f 91       	pop	r17
 616:	0f 91       	pop	r16
 618:	08 95       	ret

0000061a <receiveEvent(int)>:
_Z12receiveEventi():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:176
}


void receiveEvent(int numberOfBytesReceived)
{
  while (Wire.available())
 61a:	46 dd       	rcall	.-1396   	; 0xa8 <TwoWire::available() [clone .constprop.5]>
 61c:	89 2b       	or	r24, r25
 61e:	c1 f0       	breq	.+48     	; 0x650 <receiveEvent(int)+0x36>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:179
  {
    //Record bytes to local array
    byte incoming = Wire.read();
 620:	54 dd       	rcall	.-1368   	; 0xca <TwoWire::read() [clone .constprop.4]>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:181

    if (incoming == COMMAND_CHANGE_ADDRESS) //Set new I2C address
 622:	87 3c       	cpi	r24, 0xC7	; 199
 624:	d1 f7       	brne	.-12     	; 0x61a <receiveEvent(int)>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:183
    {
      if (Wire.available())
 626:	40 dd       	rcall	.-1408   	; 0xa8 <TwoWire::available() [clone .constprop.5]>
 628:	89 2b       	or	r24, r25
 62a:	b9 f3       	breq	.-18     	; 0x61a <receiveEvent(int)>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:185
      {
        setting_i2c_address = Wire.read();
 62c:	4e dd       	rcall	.-1380   	; 0xca <TwoWire::read() [clone .constprop.4]>
 62e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <setting_i2c_address>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:188

        //Error check
        if (setting_i2c_address < 0x08 || setting_i2c_address > 0x77)
 632:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <setting_i2c_address>
 636:	88 30       	cpi	r24, 0x08	; 8
 638:	80 f3       	brcs	.-32     	; 0x61a <receiveEvent(int)>
 63a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <setting_i2c_address>
 63e:	88 37       	cpi	r24, 0x78	; 120
 640:	60 f7       	brcc	.-40     	; 0x61a <receiveEvent(int)>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:191
          continue; //Command failed. This address is out of bounds.

        EEPROM.write(LOCATION_I2C_ADDRESS, setting_i2c_address);
 642:	60 91 61 00 	lds	r22, 0x0061	; 0x800061 <setting_i2c_address>
operator=():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\EEPROM/EEPROM.h:61
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    #if  (defined(__AVR_ATtinyX41__) && F_CPU==16000000 && CLOCK_SOURCE==0)
      EERef &operator=( uint8_t in )       { return safe_eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    #else
      EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	90 e0       	ldi	r25, 0x00	; 0
 64a:	dd d3       	rcall	.+1978   	; 0xe06 <eeprom_write_byte>
_Z12receiveEventi():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:194

        //Our I2C address may have changed because of user's command
        startI2C(); //Determine the I2C address we should be using and begin listening on I2C bus
 64c:	30 df       	rcall	.-416    	; 0x4ae <startI2C()>
 64e:	e5 cf       	rjmp	.-54     	; 0x61a <receiveEvent(int)>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:198
      }
    }
  }
}
 650:	08 95       	ret

00000652 <__vector_11>:
__vector_11():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:139
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
 652:	1f 92       	push	r1
 654:	0f 92       	push	r0
 656:	0f b6       	in	r0, 0x3f	; 63
 658:	0f 92       	push	r0
 65a:	11 24       	eor	r1, r1
 65c:	2f 93       	push	r18
 65e:	3f 93       	push	r19
 660:	8f 93       	push	r24
 662:	9f 93       	push	r25
 664:	af 93       	push	r26
 666:	bf 93       	push	r27
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:142
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
 668:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <millis_timer_millis>
 66c:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <millis_timer_millis+0x1>
 670:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <millis_timer_millis+0x2>
 674:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <millis_timer_millis+0x3>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:143
    unsigned char f = millis_timer_fract;
 678:	30 91 e4 00 	lds	r19, 0x00E4	; 0x8000e4 <millis_timer_fract>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:145

    f += FRACT_INC;
 67c:	26 e0       	ldi	r18, 0x06	; 6
 67e:	23 0f       	add	r18, r19
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:147

    if (f >= FRACT_MAX)
 680:	2d 37       	cpi	r18, 0x7D	; 125
 682:	68 f1       	brcs	.+90     	; 0x6de <__vector_11+0x8c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:149
    {
      f -= FRACT_MAX;
 684:	29 e8       	ldi	r18, 0x89	; 137
 686:	23 0f       	add	r18, r19
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:151
    m += 1;
      m += MILLIS_INC;
 688:	03 96       	adiw	r24, 0x03	; 3
 68a:	a1 1d       	adc	r26, r1
 68c:	b1 1d       	adc	r27, r1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:158
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
 68e:	20 93 e4 00 	sts	0x00E4, r18	; 0x8000e4 <millis_timer_fract>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:159
    millis_timer_millis = m;
 692:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <millis_timer_millis>
 696:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <millis_timer_millis+0x1>
 69a:	a0 93 05 01 	sts	0x0105, r26	; 0x800105 <millis_timer_millis+0x2>
 69e:	b0 93 06 01 	sts	0x0106, r27	; 0x800106 <millis_timer_millis+0x3>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:160
    millis_timer_overflow_count++;
 6a2:	80 91 e5 00 	lds	r24, 0x00E5	; 0x8000e5 <millis_timer_overflow_count>
 6a6:	90 91 e6 00 	lds	r25, 0x00E6	; 0x8000e6 <millis_timer_overflow_count+0x1>
 6aa:	a0 91 e7 00 	lds	r26, 0x00E7	; 0x8000e7 <millis_timer_overflow_count+0x2>
 6ae:	b0 91 e8 00 	lds	r27, 0x00E8	; 0x8000e8 <millis_timer_overflow_count+0x3>
 6b2:	01 96       	adiw	r24, 0x01	; 1
 6b4:	a1 1d       	adc	r26, r1
 6b6:	b1 1d       	adc	r27, r1
 6b8:	80 93 e5 00 	sts	0x00E5, r24	; 0x8000e5 <millis_timer_overflow_count>
 6bc:	90 93 e6 00 	sts	0x00E6, r25	; 0x8000e6 <millis_timer_overflow_count+0x1>
 6c0:	a0 93 e7 00 	sts	0x00E7, r26	; 0x8000e7 <millis_timer_overflow_count+0x2>
 6c4:	b0 93 e8 00 	sts	0x00E8, r27	; 0x8000e8 <millis_timer_overflow_count+0x3>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:162

  }
 6c8:	bf 91       	pop	r27
 6ca:	af 91       	pop	r26
 6cc:	9f 91       	pop	r25
 6ce:	8f 91       	pop	r24
 6d0:	3f 91       	pop	r19
 6d2:	2f 91       	pop	r18
 6d4:	0f 90       	pop	r0
 6d6:	0f be       	out	0x3f, r0	; 63
 6d8:	0f 90       	pop	r0
 6da:	1f 90       	pop	r1
 6dc:	18 95       	reti
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:155
    m += 1;
      m += MILLIS_INC;
    }
    else
    {
      m += MILLIS_INC;
 6de:	02 96       	adiw	r24, 0x02	; 2
 6e0:	a1 1d       	adc	r26, r1
 6e2:	b1 1d       	adc	r27, r1
 6e4:	d4 cf       	rjmp	.-88     	; 0x68e <__vector_11+0x3c>

000006e6 <__vector_2>:
__vector_3():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:227
  }
}

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
 6e6:	1f 92       	push	r1
 6e8:	0f 92       	push	r0
 6ea:	0f b6       	in	r0, 0x3f	; 63
 6ec:	0f 92       	push	r0
 6ee:	11 24       	eor	r1, r1
 6f0:	2f 93       	push	r18
 6f2:	3f 93       	push	r19
 6f4:	4f 93       	push	r20
 6f6:	5f 93       	push	r21
 6f8:	6f 93       	push	r22
 6fa:	7f 93       	push	r23
 6fc:	8f 93       	push	r24
 6fe:	9f 93       	push	r25
 700:	af 93       	push	r26
 702:	bf 93       	push	r27
 704:	ef 93       	push	r30
 706:	ff 93       	push	r31
_ZN14SoftwareSerial16handle_interruptEv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:219
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
 708:	e0 91 eb 00 	lds	r30, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 70c:	f0 91 ec 00 	lds	r31, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 710:	30 97       	sbiw	r30, 0x00	; 0
 712:	49 f0       	breq	.+18     	; 0x726 <__vector_2+0x40>
 714:	a6 85       	ldd	r26, Z+14	; 0x0e
 716:	b7 85       	ldd	r27, Z+15	; 0x0f
 718:	85 85       	ldd	r24, Z+13	; 0x0d
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:144

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
 71a:	96 8d       	ldd	r25, Z+30	; 0x1e
 71c:	91 ff       	sbrs	r25, 1
 71e:	14 c0       	rjmp	.+40     	; 0x748 <__vector_2+0x62>
rx_pin_read():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:209
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 720:	9c 91       	ld	r25, X
 722:	89 23       	and	r24, r25
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:144

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
 724:	a1 f4       	brne	.+40     	; 0x74e <__vector_2+0x68>
__vector_3():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:229

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
  SoftwareSerial::handle_interrupt();
}
 726:	ff 91       	pop	r31
 728:	ef 91       	pop	r30
 72a:	bf 91       	pop	r27
 72c:	af 91       	pop	r26
 72e:	9f 91       	pop	r25
 730:	8f 91       	pop	r24
 732:	7f 91       	pop	r23
 734:	6f 91       	pop	r22
 736:	5f 91       	pop	r21
 738:	4f 91       	pop	r20
 73a:	3f 91       	pop	r19
 73c:	2f 91       	pop	r18
 73e:	0f 90       	pop	r0
 740:	0f be       	out	0x3f, r0	; 63
 742:	0f 90       	pop	r0
 744:	1f 90       	pop	r1
 746:	18 95       	reti
rx_pin_read():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:209
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 748:	9c 91       	ld	r25, X
 74a:	89 23       	and	r24, r25
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:144

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
 74c:	61 f7       	brne	.-40     	; 0x726 <__vector_2+0x40>
setRxIntMsk():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:380
void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
    else
      *_pcint_maskreg &= ~_pcint_maskvalue;
 74e:	a3 89       	ldd	r26, Z+19	; 0x13
 750:	b4 89       	ldd	r27, Z+20	; 0x14
 752:	9c 91       	ld	r25, X
 754:	85 89       	ldd	r24, Z+21	; 0x15
 756:	80 95       	com	r24
 758:	89 23       	and	r24, r25
 75a:	8c 93       	st	X, r24
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
 75c:	86 89       	ldd	r24, Z+22	; 0x16
 75e:	97 89       	ldd	r25, Z+23	; 0x17
 760:	01 97       	sbiw	r24, 0x01	; 1
 762:	f1 f7       	brne	.-4      	; 0x760 <__vector_2+0x7a>
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:158
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=8; i > 0; --i)
    {
      tunedDelay(_rx_delay_intrabit);
 764:	60 8d       	ldd	r22, Z+24	; 0x18
 766:	71 8d       	ldd	r23, Z+25	; 0x19
rx_pin_read():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:209
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 768:	a6 85       	ldd	r26, Z+14	; 0x0e
 76a:	b7 85       	ldd	r27, Z+15	; 0x0f
 76c:	55 85       	ldd	r21, Z+13	; 0x0d
 76e:	38 e0       	ldi	r19, 0x08	; 8
__vector_3():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:140
    "push r26 \n\t"
    "push r27 \n\t"
    ::);
#endif

  uint8_t d = 0;
 770:	20 e0       	ldi	r18, 0x00	; 0
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
 772:	cb 01       	movw	r24, r22
 774:	01 97       	sbiw	r24, 0x01	; 1
 776:	f1 f7       	brne	.-4      	; 0x774 <__vector_2+0x8e>
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:159

    // Read each of the 8 bits
    for (uint8_t i=8; i > 0; --i)
    {
      tunedDelay(_rx_delay_intrabit);
      d >>= 1;
 778:	82 2f       	mov	r24, r18
 77a:	90 e0       	ldi	r25, 0x00	; 0
 77c:	95 95       	asr	r25
 77e:	87 95       	ror	r24
 780:	28 2f       	mov	r18, r24
rx_pin_read():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:209
#endif
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
 782:	4c 91       	ld	r20, X
 784:	45 23       	and	r20, r21
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:161
    for (uint8_t i=8; i > 0; --i)
    {
      tunedDelay(_rx_delay_intrabit);
      d >>= 1;
      DebugPulse(_DEBUG_PIN2, 1);
      if (rx_pin_read())
 786:	09 f0       	breq	.+2      	; 0x78a <__vector_2+0xa4>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:162
        d |= 0x80;
 788:	20 68       	ori	r18, 0x80	; 128
 78a:	31 50       	subi	r19, 0x01	; 1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:156
    // Wait approximately 1/2 of a bit width to "center" the sample
    tunedDelay(_rx_delay_centering);
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=8; i > 0; --i)
 78c:	91 f7       	brne	.-28     	; 0x772 <__vector_2+0x8c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:165
      DebugPulse(_DEBUG_PIN2, 1);
      if (rx_pin_read())
        d |= 0x80;
    }

    if (_inverse_logic)
 78e:	86 8d       	ldd	r24, Z+30	; 0x1e
 790:	81 fd       	sbrc	r24, 1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:166
      d = ~d;
 792:	20 95       	com	r18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:169

    // if buffer full, set the overflow flag and return
    uint8_t next = (_receive_buffer_tail + 1) % _SS_MAX_RX_BUFF;
 794:	80 91 ea 00 	lds	r24, 0x00EA	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 798:	90 e0       	ldi	r25, 0x00	; 0
 79a:	01 96       	adiw	r24, 0x01	; 1
 79c:	8f 73       	andi	r24, 0x3F	; 63
 79e:	99 27       	eor	r25, r25
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:170
    if (next != _receive_buffer_head)
 7a0:	30 91 e9 00 	lds	r19, 0x00E9	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
 7a4:	38 17       	cp	r19, r24
 7a6:	99 f0       	breq	.+38     	; 0x7ce <__vector_2+0xe8>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:173
    {
      // save new data in buffer: tail points to where byte goes
      _receive_buffer[_receive_buffer_tail] = d; // save new byte
 7a8:	a0 91 ea 00 	lds	r26, 0x00EA	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 7ac:	b0 e0       	ldi	r27, 0x00	; 0
 7ae:	ac 55       	subi	r26, 0x5C	; 92
 7b0:	bf 4f       	sbci	r27, 0xFF	; 255
 7b2:	2c 93       	st	X, r18
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:174
      _receive_buffer_tail = next;
 7b4:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
 7b8:	82 8d       	ldd	r24, Z+26	; 0x1a
 7ba:	93 8d       	ldd	r25, Z+27	; 0x1b
 7bc:	01 97       	sbiw	r24, 0x01	; 1
 7be:	f1 f7       	brne	.-4      	; 0x7bc <__vector_2+0xd6>
setRxIntMsk():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:378
}

void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
 7c0:	a3 89       	ldd	r26, Z+19	; 0x13
 7c2:	b4 89       	ldd	r27, Z+20	; 0x14
 7c4:	8c 91       	ld	r24, X
 7c6:	95 89       	ldd	r25, Z+21	; 0x15
 7c8:	89 2b       	or	r24, r25
 7ca:	8c 93       	st	X, r24
 7cc:	ac cf       	rjmp	.-168    	; 0x726 <__vector_2+0x40>
recv():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:179
      _receive_buffer_tail = next;
    }
    else
    {
      DebugPulse(_DEBUG_PIN1, 1);
      _buffer_overflow = true;
 7ce:	86 8d       	ldd	r24, Z+30	; 0x1e
 7d0:	81 60       	ori	r24, 0x01	; 1
 7d2:	86 8f       	std	Z+30, r24	; 0x1e
 7d4:	f1 cf       	rjmp	.-30     	; 0x7b8 <__vector_2+0xd2>

000007d6 <__vector_16>:
__vector_16():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
ISR(USI_OVERFLOW_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_OVERFLOW_VECTOR
__interrupt void USI_Counter_Overflow_ISR(void)
#endif
{
 7d6:	1f 92       	push	r1
 7d8:	0f 92       	push	r0
 7da:	0f b6       	in	r0, 0x3f	; 63
 7dc:	0f 92       	push	r0
 7de:	11 24       	eor	r1, r1
 7e0:	2f 93       	push	r18
 7e2:	3f 93       	push	r19
 7e4:	4f 93       	push	r20
 7e6:	5f 93       	push	r21
 7e8:	6f 93       	push	r22
 7ea:	7f 93       	push	r23
 7ec:	8f 93       	push	r24
 7ee:	9f 93       	push	r25
 7f0:	af 93       	push	r26
 7f2:	bf 93       	push	r27
 7f4:	cf 93       	push	r28
 7f6:	ef 93       	push	r30
 7f8:	ff 93       	push	r31
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 7fa:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <USI_TWI_Overflow_State>
 7fe:	82 30       	cpi	r24, 0x02	; 2
 800:	09 f4       	brne	.+2      	; 0x804 <__vector_16+0x2e>
 802:	74 c0       	rjmp	.+232    	; 0x8ec <__vector_16+0x116>
 804:	b8 f4       	brcc	.+46     	; 0x834 <__vector_16+0x5e>
 806:	88 23       	and	r24, r24
 808:	89 f1       	breq	.+98     	; 0x86c <__vector_16+0x96>
 80a:	81 30       	cpi	r24, 0x01	; 1
 80c:	09 f4       	brne	.+2      	; 0x810 <__vector_16+0x3a>
 80e:	54 c0       	rjmp	.+168    	; 0x8b8 <__vector_16+0xe2>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:310
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 810:	ff 91       	pop	r31
 812:	ef 91       	pop	r30
 814:	cf 91       	pop	r28
 816:	bf 91       	pop	r27
 818:	af 91       	pop	r26
 81a:	9f 91       	pop	r25
 81c:	8f 91       	pop	r24
 81e:	7f 91       	pop	r23
 820:	6f 91       	pop	r22
 822:	5f 91       	pop	r21
 824:	4f 91       	pop	r20
 826:	3f 91       	pop	r19
 828:	2f 91       	pop	r18
 82a:	0f 90       	pop	r0
 82c:	0f be       	out	0x3f, r0	; 63
 82e:	0f 90       	pop	r0
 830:	1f 90       	pop	r1
 832:	18 95       	reti
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 834:	84 30       	cpi	r24, 0x04	; 4
 836:	09 f4       	brne	.+2      	; 0x83a <__vector_16+0x64>
 838:	5f c0       	rjmp	.+190    	; 0x8f8 <__vector_16+0x122>
 83a:	b8 f1       	brcs	.+110    	; 0x8aa <__vector_16+0xd4>
 83c:	85 30       	cpi	r24, 0x05	; 5
 83e:	41 f7       	brne	.-48     	; 0x810 <__vector_16+0x3a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:297
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 840:	84 e0       	ldi	r24, 0x04	; 4
 842:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <USI_TWI_Overflow_State>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:298
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 846:	9f b1       	in	r25, 0x0f	; 15
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:299
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 848:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_RxHead>
 84c:	8f 5f       	subi	r24, 0xFF	; 255
 84e:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:300
    if (TWI_RxTail != tmpRxHead) {
 850:	20 91 f1 01 	lds	r18, 0x01F1	; 0x8001f1 <TWI_RxTail>
 854:	28 17       	cp	r18, r24
 856:	09 f4       	brne	.+2      	; 0x85a <__vector_16+0x84>
 858:	73 c0       	rjmp	.+230    	; 0x940 <__vector_16+0x16a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:301
      TWI_RxHead            = tmpRxHead;
 85a:	80 93 f0 01 	sts	0x01F0, r24	; 0x8001f0 <TWI_RxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 85e:	e0 91 f0 01 	lds	r30, 0x01F0	; 0x8001f0 <TWI_RxHead>
 862:	f0 e0       	ldi	r31, 0x00	; 0
 864:	ee 58       	subi	r30, 0x8E	; 142
 866:	ff 4f       	sbci	r31, 0xFF	; 255
 868:	90 83       	st	Z, r25
 86a:	19 c0       	rjmp	.+50     	; 0x89e <__vector_16+0xc8>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:221

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 86c:	8f b1       	in	r24, 0x0f	; 15
 86e:	88 23       	and	r24, r24
 870:	31 f0       	breq	.+12     	; 0x87e <__vector_16+0xa8>
 872:	8f b1       	in	r24, 0x0f	; 15
 874:	86 95       	lsr	r24
 876:	90 91 a2 00 	lds	r25, 0x00A2	; 0x8000a2 <TWI_slaveAddress>
 87a:	89 13       	cpse	r24, r25
 87c:	19 c0       	rjmp	.+50     	; 0x8b0 <__vector_16+0xda>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:222
      if (USIDR & 0x01) {
 87e:	78 9b       	sbis	0x0f, 0	; 15
 880:	12 c0       	rjmp	.+36     	; 0x8a6 <__vector_16+0xd0>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:223
        if (USI_TWI_On_Slave_Transmit) {
 882:	e0 91 a0 00 	lds	r30, 0x00A0	; 0x8000a0 <USI_TWI_On_Slave_Transmit>
 886:	f0 91 a1 00 	lds	r31, 0x00A1	; 0x8000a1 <USI_TWI_On_Slave_Transmit+0x1>
 88a:	30 97       	sbiw	r30, 0x00	; 0
 88c:	29 f0       	breq	.+10     	; 0x898 <__vector_16+0xc2>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:225
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
 88e:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <TWI_TxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
          TWI_TxTail = tmpTxTail;
 892:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <TWI_TxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:227
          USI_TWI_On_Slave_Transmit();
 896:	09 95       	icall
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:229
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 898:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:231
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 89a:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <USI_TWI_Overflow_State>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:233
      }
      SET_USI_TO_SEND_ACK();
 89e:	1f b8       	out	0x0f, r1	; 15
 8a0:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 8a2:	8e e7       	ldi	r24, 0x7E	; 126
 8a4:	21 c0       	rjmp	.+66     	; 0x8e8 <__vector_16+0x112>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:231
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 8a6:	84 e0       	ldi	r24, 0x04	; 4
 8a8:	f8 cf       	rjmp	.-16     	; 0x89a <__vector_16+0xc4>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:242
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 8aa:	8f b1       	in	r24, 0x0f	; 15
 8ac:	88 23       	and	r24, r24
 8ae:	21 f0       	breq	.+8      	; 0x8b8 <__vector_16+0xe2>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 8b0:	d6 98       	cbi	0x1a, 6	; 26
 8b2:	88 ea       	ldi	r24, 0xA8	; 168
 8b4:	8d b9       	out	0x0d, r24	; 13
 8b6:	17 c0       	rjmp	.+46     	; 0x8e6 <__vector_16+0x110>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:253

  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 8b8:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <TWI_TxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:254
    if (TWI_TxHead != tmpTxTail) {
 8bc:	90 91 9f 00 	lds	r25, 0x009F	; 0x80009f <TWI_TxHead>
 8c0:	98 17       	cp	r25, r24
 8c2:	b1 f3       	breq	.-20     	; 0x8b0 <__vector_16+0xda>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 8c4:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <TWI_TxTail>
 8c8:	8f 5f       	subi	r24, 0xFF	; 255
 8ca:	8f 70       	andi	r24, 0x0F	; 15
 8cc:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <TWI_TxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:256
      USIDR      = TWI_TxBuf[TWI_TxTail];
 8d0:	e0 91 9e 00 	lds	r30, 0x009E	; 0x80009e <TWI_TxTail>
 8d4:	f0 e0       	ldi	r31, 0x00	; 0
 8d6:	ee 57       	subi	r30, 0x7E	; 126
 8d8:	ff 4f       	sbci	r31, 0xFF	; 255
 8da:	80 81       	ld	r24, Z
 8dc:	8f b9       	out	0x0f, r24	; 15
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:262
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 8de:	82 e0       	ldi	r24, 0x02	; 2
 8e0:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <USI_TWI_Overflow_State>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:263
    SET_USI_TO_SEND_DATA();
 8e4:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 8e6:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 8e8:	8e b9       	out	0x0e, r24	; 14
 8ea:	92 cf       	rjmp	.-220    	; 0x810 <__vector_16+0x3a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:268
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 8ec:	83 e0       	ldi	r24, 0x03	; 3
 8ee:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <USI_TWI_Overflow_State>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:269
    SET_USI_TO_READ_ACK();
 8f2:	d6 98       	cbi	0x1a, 6	; 26
 8f4:	1f b8       	out	0x0f, r1	; 15
 8f6:	d5 cf       	rjmp	.-86     	; 0x8a2 <__vector_16+0xcc>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:275
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 8f8:	85 e0       	ldi	r24, 0x05	; 5
 8fa:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <USI_TWI_Overflow_State>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:276
    SET_USI_TO_READ_DATA();
 8fe:	d6 98       	cbi	0x1a, 6	; 26
 900:	80 e7       	ldi	r24, 0x70	; 112
 902:	8e b9       	out	0x0e, r24	; 14
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:278
    // call slave receive callback on stop condition
    if (USI_TWI_On_Slave_Receive) {
 904:	e0 91 9c 00 	lds	r30, 0x009C	; 0x80009c <USI_TWI_On_Slave_Receive>
 908:	f0 91 9d 00 	lds	r31, 0x009D	; 0x80009d <USI_TWI_On_Slave_Receive+0x1>
 90c:	30 97       	sbiw	r30, 0x00	; 0
 90e:	09 f4       	brne	.+2      	; 0x912 <__vector_16+0x13c>
 910:	7f cf       	rjmp	.-258    	; 0x810 <__vector_16+0x3a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:279
      tmpRxHead = TWI_RxHead;
 912:	c0 91 f0 01 	lds	r28, 0x01F0	; 0x8001f0 <TWI_RxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:280
      if (TWI_RxTail != tmpRxHead) { // data in receive buffer
 916:	80 91 f1 01 	lds	r24, 0x01F1	; 0x8001f1 <TWI_RxTail>
 91a:	8c 17       	cp	r24, r28
 91c:	09 f4       	brne	.+2      	; 0x920 <__vector_16+0x14a>
 91e:	78 cf       	rjmp	.-272    	; 0x810 <__vector_16+0x3a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:282
        // check for stop Condition
        while ((USISR & ((1 << USI_START_COND_INT) | (1 << USIPF) | (0xE << USICNT0))) == 0)
 920:	8e b1       	in	r24, 0x0e	; 14
 922:	8e 7a       	andi	r24, 0xAE	; 174
 924:	e9 f3       	breq	.-6      	; 0x920 <__vector_16+0x14a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:285
          ;// wait for either Start or Stop Condition
          // cancel after one SCL cycle
        if (USISR & (1 << USIPF)) { // Stop Condition
 926:	75 9b       	sbis	0x0e, 5	; 14
 928:	73 cf       	rjmp	.-282    	; 0x810 <__vector_16+0x3a>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 92a:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 92e:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_RxHead>
 932:	89 1b       	sub	r24, r25
 934:	8f 70       	andi	r24, 0x0F	; 15
__vector_16():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:286
        // check for stop Condition
        while ((USISR & ((1 << USI_START_COND_INT) | (1 << USIPF) | (0xE << USICNT0))) == 0)
          ;// wait for either Start or Stop Condition
          // cancel after one SCL cycle
        if (USISR & (1 << USIPF)) { // Stop Condition
          USI_TWI_On_Slave_Receive(USI_TWI_Data_In_Receive_Buffer());
 936:	90 e0       	ldi	r25, 0x00	; 0
 938:	09 95       	icall
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:288
          // reset rx buffer
          TWI_RxTail = tmpRxHead;
 93a:	c0 93 f1 01 	sts	0x01F1, r28	; 0x8001f1 <TWI_RxTail>
 93e:	68 cf       	rjmp	.-304    	; 0x810 <__vector_16+0x3a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 940:	d6 98       	cbi	0x1a, 6	; 26
 942:	af cf       	rjmp	.-162    	; 0x8a2 <__vector_16+0xcc>

00000944 <__vector_15>:
__vector_15():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 944:	1f 92       	push	r1
 946:	0f 92       	push	r0
 948:	0f b6       	in	r0, 0x3f	; 63
 94a:	0f 92       	push	r0
 94c:	11 24       	eor	r1, r1
 94e:	2f 93       	push	r18
 950:	3f 93       	push	r19
 952:	4f 93       	push	r20
 954:	5f 93       	push	r21
 956:	6f 93       	push	r22
 958:	7f 93       	push	r23
 95a:	8f 93       	push	r24
 95c:	9f 93       	push	r25
 95e:	af 93       	push	r26
 960:	bf 93       	push	r27
 962:	cf 93       	push	r28
 964:	ef 93       	push	r30
 966:	ff 93       	push	r31
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:169
  unsigned char tmpPin; // Temporary variable for pin state
  unsigned char tmpRxHead; // Temporary variable to store volatile
  // call slave receive callback on repeated start
  if (USI_TWI_On_Slave_Receive) {
 968:	e0 91 9c 00 	lds	r30, 0x009C	; 0x80009c <USI_TWI_On_Slave_Receive>
 96c:	f0 91 9d 00 	lds	r31, 0x009D	; 0x80009d <USI_TWI_On_Slave_Receive+0x1>
 970:	30 97       	sbiw	r30, 0x00	; 0
 972:	81 f0       	breq	.+32     	; 0x994 <__vector_15+0x50>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:170
    tmpRxHead = TWI_RxHead;
 974:	c0 91 f0 01 	lds	r28, 0x01F0	; 0x8001f0 <TWI_RxHead>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:171
    if (TWI_RxTail != tmpRxHead) { // data in receive buffer
 978:	80 91 f1 01 	lds	r24, 0x01F1	; 0x8001f1 <TWI_RxTail>
 97c:	8c 17       	cp	r24, r28
 97e:	51 f0       	breq	.+20     	; 0x994 <__vector_15+0x50>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 980:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 984:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_RxHead>
 988:	89 1b       	sub	r24, r25
 98a:	8f 70       	andi	r24, 0x0F	; 15
__vector_15():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:172
  unsigned char tmpRxHead; // Temporary variable to store volatile
  // call slave receive callback on repeated start
  if (USI_TWI_On_Slave_Receive) {
    tmpRxHead = TWI_RxHead;
    if (TWI_RxTail != tmpRxHead) { // data in receive buffer
      USI_TWI_On_Slave_Receive(USI_TWI_Data_In_Receive_Buffer());
 98c:	90 e0       	ldi	r25, 0x00	; 0
 98e:	09 95       	icall
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:174
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
 990:	c0 93 f1 01 	sts	0x01F1, r28	; 0x8001f1 <TWI_RxTail>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:178
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 994:	10 92 a3 00 	sts	0x00A3, r1	; 0x8000a3 <USI_TWI_Overflow_State>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 998:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 99a:	cc 9b       	sbis	0x19, 4	; 25
 99c:	18 c0       	rjmp	.+48     	; 0x9ce <__vector_15+0x8a>
 99e:	ce 9b       	sbis	0x19, 6	; 25
 9a0:	fc cf       	rjmp	.-8      	; 0x99a <__vector_15+0x56>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 9a2:	88 ea       	ldi	r24, 0xA8	; 168
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 9a4:	8d b9       	out	0x0d, r24	; 13
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 9a6:	80 ef       	ldi	r24, 0xF0	; 240
 9a8:	8e b9       	out	0x0e, r24	; 14
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 9aa:	ff 91       	pop	r31
 9ac:	ef 91       	pop	r30
 9ae:	cf 91       	pop	r28
 9b0:	bf 91       	pop	r27
 9b2:	af 91       	pop	r26
 9b4:	9f 91       	pop	r25
 9b6:	8f 91       	pop	r24
 9b8:	7f 91       	pop	r23
 9ba:	6f 91       	pop	r22
 9bc:	5f 91       	pop	r21
 9be:	4f 91       	pop	r20
 9c0:	3f 91       	pop	r19
 9c2:	2f 91       	pop	r18
 9c4:	0f 90       	pop	r0
 9c6:	0f be       	out	0x3f, r0	; 63
 9c8:	0f 90       	pop	r0
 9ca:	1f 90       	pop	r1
 9cc:	18 95       	reti
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 9ce:	88 ef       	ldi	r24, 0xF8	; 248
 9d0:	e9 cf       	rjmp	.-46     	; 0x9a4 <__vector_15+0x60>

000009d2 <main>:
main():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:904
  */

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 9d2:	83 e0       	ldi	r24, 0x03	; 3
 9d4:	80 bf       	out	0x30, r24	; 48
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:907
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 9d6:	83 bf       	out	0x33, r24	; 51
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:928
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 9d8:	78 94       	sei
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:935
  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
    #elif defined(TIMSK0) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK0, TOIE0);
 9da:	99 b7       	in	r25, 0x39	; 57
 9dc:	91 60       	ori	r25, 0x01	; 1
 9de:	99 bf       	out	0x39, r25	; 57
initToneTimerInternal():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:608
    #elif (TIMER_TO_USE_FOR_TONE == 1 ) && defined(__AVR_ATtinyX7__)
      TCCR1A = (1<<COM1A1)|(1<<COM1B1)|(1<<WGM10);
      TCCR1B = (ToneTimer_Prescale_Index << CS10)|(1<<WGM12);
    #elif (TIMER_TO_USE_FOR_TONE == 1) // x4, x8, x313,
      // Use the Tone Timer for phase correct PWM
      TCCR1A = (1<<WGM10) | (1<<WGM11);
 9e0:	8f bd       	out	0x2f, r24	; 47
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:609
      TCCR1B = (0<<WGM12) | (0<<WGM13) | (ToneTimer_Prescale_Index << CS10); //set the clock
 9e2:	8e bd       	out	0x2e, r24	; 46
main():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:972

  // Initialize the ADC
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 9e4:	86 b1       	in	r24, 0x06	; 6
 9e6:	88 77       	andi	r24, 0x78	; 120
 9e8:	86 68       	ori	r24, 0x86	; 134
 9ea:	86 b9       	out	0x06, r24	; 6
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:974
      // enable a2d conversions
      sbi(ADCSRA, ADEN);
 9ec:	37 9a       	sbi	0x06, 7	; 6
setup():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:72
byte tempInc[TAG_ID_SIZE]; 
byte tempTagID[6];

void setup(void)
{
  pinMode(addrPin, INPUT_PULLUP); //Default HIGH = 0x13
 9ee:	62 e0       	ldi	r22, 0x02	; 2
 9f0:	80 e0       	ldi	r24, 0x00	; 0
 9f2:	f6 db       	rcall	.-2068   	; 0x1e0 <pinMode>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:73
  pinMode(interruptPin, OUTPUT); //Tied high and goes low when an RFID has been scanned.
 9f4:	61 e0       	ldi	r22, 0x01	; 1
 9f6:	83 e0       	ldi	r24, 0x03	; 3
 9f8:	f3 db       	rcall	.-2074   	; 0x1e0 <pinMode>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:75

  pinMode(rxPin, INPUT); 
 9fa:	60 e0       	ldi	r22, 0x00	; 0
 9fc:	82 e0       	ldi	r24, 0x02	; 2
 9fe:	f0 db       	rcall	.-2080   	; 0x1e0 <pinMode>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:76
  pinMode(txPin, OUTPUT); 
 a00:	61 e0       	ldi	r22, 0x01	; 1
 a02:	81 e0       	ldi	r24, 0x01	; 1
 a04:	ed db       	rcall	.-2086   	; 0x1e0 <pinMode>
begin():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:304
// Public methods
//

void SoftwareSerial::begin(long speed)
{
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
 a06:	10 92 ec 01 	sts	0x01EC, r1	; 0x8001ec <atSerial+0x1b>
 a0a:	10 92 eb 01 	sts	0x01EB, r1	; 0x8001eb <atSerial+0x1a>
 a0e:	10 92 ea 01 	sts	0x01EA, r1	; 0x8001ea <atSerial+0x19>
 a12:	10 92 e9 01 	sts	0x01E9, r1	; 0x8001e9 <atSerial+0x18>
 a16:	10 92 e8 01 	sts	0x01E8, r1	; 0x8001e8 <atSerial+0x17>
 a1a:	10 92 e7 01 	sts	0x01E7, r1	; 0x8001e7 <atSerial+0x16>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:314
  // 12 (gcc 4.8.2) or 13 (gcc 4.3.2) cycles from start bit to first bit,
  // 15 (gcc 4.8.2) or 16 (gcc 4.3.2) cycles between bits,
  // 12 (gcc 4.8.2) or 14 (gcc 4.3.2) cycles from last bit to stop bit
  // These are all close enough to just use 15 cycles, since the inter-bit
  // timings are the most critical (deviations stack 8 times)
  _tx_delay = subtract_cap(bit_delay, 15 / 4);
 a1e:	8d ec       	ldi	r24, 0xCD	; 205
 a20:	90 e0       	ldi	r25, 0x00	; 0
 a22:	90 93 ee 01 	sts	0x01EE, r25	; 0x8001ee <atSerial+0x1d>
 a26:	80 93 ed 01 	sts	0x01ED, r24	; 0x8001ed <atSerial+0x1c>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:317

  // Only setup rx when we have a valid PCINT for this pin
  if (digitalPinToPCICR(_receivePin)) {
 a2a:	90 91 dd 01 	lds	r25, 0x01DD	; 0x8001dd <atSerial+0xc>
 a2e:	9c 30       	cpi	r25, 0x0C	; 12
 a30:	c8 f5       	brcc	.+114    	; 0xaa4 <main+0xd2>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:332
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
 a32:	25 e5       	ldi	r18, 0x55	; 85
 a34:	30 e0       	ldi	r19, 0x00	; 0
 a36:	30 93 e8 01 	sts	0x01E8, r19	; 0x8001e8 <atSerial+0x17>
 a3a:	20 93 e7 01 	sts	0x01E7, r18	; 0x8001e7 <atSerial+0x16>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:335

    // There are 23 cycles in each loop iteration (excluding the delay)
    _rx_delay_intrabit = subtract_cap(bit_delay, 23 / 4);
 a3e:	2b ec       	ldi	r18, 0xCB	; 203
 a40:	30 e0       	ldi	r19, 0x00	; 0
 a42:	30 93 ea 01 	sts	0x01EA, r19	; 0x8001ea <atSerial+0x19>
 a46:	20 93 e9 01 	sts	0x01E9, r18	; 0x8001e9 <atSerial+0x18>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:344
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
 a4a:	20 e9       	ldi	r18, 0x90	; 144
 a4c:	30 e0       	ldi	r19, 0x00	; 0
 a4e:	30 93 ec 01 	sts	0x01EC, r19	; 0x8001ec <atSerial+0x1b>
 a52:	20 93 eb 01 	sts	0x01EB, r18	; 0x8001eb <atSerial+0x1a>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:358


    // Enable the PCINT for the entire port here, but never disable it
    // (others might also need it, so we disable the interrupt by using
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
 a56:	8b b7       	in	r24, 0x3b	; 59
main():
 a58:	20 e1       	ldi	r18, 0x10	; 16
begin():
 a5a:	98 30       	cpi	r25, 0x08	; 8
 a5c:	08 f0       	brcs	.+2      	; 0xa60 <main+0x8e>
main():
 a5e:	20 e2       	ldi	r18, 0x20	; 32
begin():
 a60:	82 2b       	or	r24, r18
 a62:	8b bf       	out	0x3b, r24	; 59
main():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:361
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
 a64:	22 e3       	ldi	r18, 0x32	; 50
 a66:	30 e0       	ldi	r19, 0x00	; 0
begin():
 a68:	98 30       	cpi	r25, 0x08	; 8
 a6a:	30 f0       	brcs	.+12     	; 0xa78 <main+0xa6>
main():
 a6c:	20 e4       	ldi	r18, 0x40	; 64
 a6e:	30 e0       	ldi	r19, 0x00	; 0
begin():
 a70:	9b 30       	cpi	r25, 0x0B	; 11
 a72:	10 f0       	brcs	.+4      	; 0xa78 <main+0xa6>
main():
 a74:	30 e0       	ldi	r19, 0x00	; 0
 a76:	20 e0       	ldi	r18, 0x00	; 0
begin():
 a78:	30 93 e5 01 	sts	0x01E5, r19	; 0x8001e5 <atSerial+0x14>
 a7c:	20 93 e4 01 	sts	0x01E4, r18	; 0x8001e4 <atSerial+0x13>
 a80:	49 2f       	mov	r20, r25
 a82:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:362
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
 a84:	98 30       	cpi	r25, 0x08	; 8
 a86:	08 f0       	brcs	.+2      	; 0xa8a <main+0xb8>
 a88:	f4 c0       	rjmp	.+488    	; 0xc72 <main+0x2a0>
 a8a:	81 e0       	ldi	r24, 0x01	; 1
 a8c:	01 c0       	rjmp	.+2      	; 0xa90 <main+0xbe>
 a8e:	88 0f       	add	r24, r24
 a90:	9a 95       	dec	r25
 a92:	ea f7       	brpl	.-6      	; 0xa8e <main+0xbc>
 a94:	80 93 e6 01 	sts	0x01E6, r24	; 0x8001e6 <atSerial+0x15>
_delay_loop_2():
c:\users\elias\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:110
 a98:	80 91 ed 01 	lds	r24, 0x01ED	; 0x8001ed <atSerial+0x1c>
 a9c:	90 91 ee 01 	lds	r25, 0x01EE	; 0x8001ee <atSerial+0x1d>
 aa0:	01 97       	sbiw	r24, 0x01	; 1
 aa2:	f1 f7       	brne	.-4      	; 0xaa0 <main+0xce>
listen():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:87

// This function sets the current object as the "listening"
// one and returns true if it replaces another
bool SoftwareSerial::listen()
{
  if (!_rx_delay_stopbit)
 aa4:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <atSerial+0x1a>
 aa8:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <atSerial+0x1b>
 aac:	89 2b       	or	r24, r25
 aae:	49 f1       	breq	.+82     	; 0xb02 <main+0x130>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:90
    return false;

  if (active_object != this)
 ab0:	e0 91 eb 00 	lds	r30, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 ab4:	f0 91 ec 00 	lds	r31, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 ab8:	81 e0       	ldi	r24, 0x01	; 1
 aba:	e1 3d       	cpi	r30, 0xD1	; 209
 abc:	f8 07       	cpc	r31, r24
 abe:	09 f1       	breq	.+66     	; 0xb02 <main+0x130>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:92
  {
    if (active_object)
 ac0:	30 97       	sbiw	r30, 0x00	; 0
 ac2:	39 f0       	breq	.+14     	; 0xad2 <main+0x100>
setRxIntMsk():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:380
void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
    else
      *_pcint_maskreg &= ~_pcint_maskvalue;
 ac4:	a3 89       	ldd	r26, Z+19	; 0x13
 ac6:	b4 89       	ldd	r27, Z+20	; 0x14
 ac8:	9c 91       	ld	r25, X
 aca:	85 89       	ldd	r24, Z+21	; 0x15
 acc:	80 95       	com	r24
 ace:	89 23       	and	r24, r25
 ad0:	8c 93       	st	X, r24
listen():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:95
  if (active_object != this)
  {
    if (active_object)
      active_object->stopListening();

    _buffer_overflow = false;
 ad2:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <atSerial+0x1e>
 ad6:	8e 7f       	andi	r24, 0xFE	; 254
 ad8:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <atSerial+0x1e>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:96
    _receive_buffer_head = _receive_buffer_tail = 0;
 adc:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <SoftwareSerial::_receive_buffer_tail>
 ae0:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <SoftwareSerial::_receive_buffer_head>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:97
    active_object = this;
 ae4:	81 ed       	ldi	r24, 0xD1	; 209
 ae6:	91 e0       	ldi	r25, 0x01	; 1
 ae8:	90 93 ec 00 	sts	0x00EC, r25	; 0x8000ec <SoftwareSerial::active_object+0x1>
 aec:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <SoftwareSerial::active_object>
setRxIntMsk():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:378
}

void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
 af0:	e0 91 e4 01 	lds	r30, 0x01E4	; 0x8001e4 <atSerial+0x13>
 af4:	f0 91 e5 01 	lds	r31, 0x01E5	; 0x8001e5 <atSerial+0x14>
 af8:	80 81       	ld	r24, Z
 afa:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <atSerial+0x15>
 afe:	89 2b       	or	r24, r25
 b00:	80 83       	st	Z, r24
setup():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:80
	atSerial.begin(9600); //Baud requirement for the ID Module

  //Disable ADC
  ADCSRA = 0;
 b02:	16 b8       	out	0x06, r1	; 6
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:82
  //Disble Brown-Out Detect
  MCUCR = bit (BODS) | bit (BODSE);
 b04:	84 e8       	ldi	r24, 0x84	; 132
 b06:	85 bf       	out	0x35, r24	; 53
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:83
  MCUCR = bit (BODS);
 b08:	80 e8       	ldi	r24, 0x80	; 128
 b0a:	85 bf       	out	0x35, r24	; 53
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:87

  //Power down various bits of hardware to lower power usage
  //set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  set_sleep_mode(SLEEP_MODE_IDLE);
 b0c:	85 b7       	in	r24, 0x35	; 53
 b0e:	87 7e       	andi	r24, 0xE7	; 231
 b10:	85 bf       	out	0x35, r24	; 53
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:88
  sleep_enable();
 b12:	85 b7       	in	r24, 0x35	; 53
 b14:	80 62       	ori	r24, 0x20	; 32
 b16:	85 bf       	out	0x35, r24	; 53
operator*():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\EEPROM/EEPROM.h:53

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
 b18:	81 e0       	ldi	r24, 0x01	; 1
 b1a:	90 e0       	ldi	r25, 0x00	; 0
 b1c:	6c d1       	rcall	.+728    	; 0xdf6 <eeprom_read_byte>
readSystemSettings():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:240
//Reads the current system settings from EEPROM
//If anything looks weird, reset setting to default value
void readSystemSettings(void)
{
  //Read what I2C address we should use
  setting_i2c_address = EEPROM.read(LOCATION_I2C_ADDRESS);
 b1e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <setting_i2c_address>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:241
  if (setting_i2c_address == 255)
 b22:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <setting_i2c_address>
 b26:	8f 3f       	cpi	r24, 0xFF	; 255
 b28:	09 f0       	breq	.+2      	; 0xb2c <main+0x15a>
 b2a:	ad c0       	rjmp	.+346    	; 0xc86 <main+0x2b4>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:243
  {
    setting_i2c_address = I2C_ADDRESS_DEFAULT; //By default, we listen for I2C_ADDRESS_DEFAULT
 b2c:	83 e1       	ldi	r24, 0x13	; 19
 b2e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <setting_i2c_address>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:244
    EEPROM.write(LOCATION_I2C_ADDRESS, setting_i2c_address);
 b32:	60 91 61 00 	lds	r22, 0x0061	; 0x800061 <setting_i2c_address>
operator=():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\EEPROM/EEPROM.h:61
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    #if  (defined(__AVR_ATtinyX41__) && F_CPU==16000000 && CLOCK_SOURCE==0)
      EERef &operator=( uint8_t in )       { return safe_eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    #else
      EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
 b36:	81 e0       	ldi	r24, 0x01	; 1
 b38:	90 e0       	ldi	r25, 0x00	; 0
 b3a:	65 d1       	rcall	.+714    	; 0xe06 <eeprom_write_byte>
setup():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:92
  set_sleep_mode(SLEEP_MODE_IDLE);
  sleep_enable();

  readSystemSettings(); //Load all system settings from EEPROM

  startI2C(); //Determine the I2C address we should be using and begin listening on I2C bus
 b3c:	b8 dc       	rcall	.-1680   	; 0x4ae <startI2C()>
 b3e:	c2 e0       	ldi	r28, 0x02	; 2
 b40:	d1 e0       	ldi	r29, 0x01	; 1
loop():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:98
}

void loop(void)
{
  //Waiting for new RFID cards/capsules to be scanned. 
  if( atSerial.available() )
 b42:	81 ed       	ldi	r24, 0xD1	; 209
 b44:	91 e0       	ldi	r25, 0x01	; 1
 b46:	60 dc       	rcall	.-1856   	; 0x408 <SoftwareSerial::available()>
 b48:	89 2b       	or	r24, r25
 b4a:	09 f4       	brne	.+2      	; 0xb4e <main+0x17c>
 b4c:	be c0       	rjmp	.+380    	; 0xcca <main+0x2f8>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:100
	{
		while( atSerial.available() ) 
 b4e:	81 ed       	ldi	r24, 0xD1	; 209
 b50:	91 e0       	ldi	r25, 0x01	; 1
 b52:	5a dc       	rcall	.-1868   	; 0x408 <SoftwareSerial::available()>
 b54:	89 2b       	or	r24, r25
 b56:	09 f4       	brne	.+2      	; 0xb5a <main+0x188>
 b58:	ae c0       	rjmp	.+348    	; 0xcb6 <main+0x2e4>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:102
		{	
			if( atSerial.read() != startByte ) break; 
 b5a:	81 ed       	ldi	r24, 0xD1	; 209
 b5c:	91 e0       	ldi	r25, 0x01	; 1
 b5e:	6b dc       	rcall	.-1834   	; 0x436 <SoftwareSerial::read()>
 b60:	02 97       	sbiw	r24, 0x02	; 2
 b62:	09 f0       	breq	.+2      	; 0xb66 <main+0x194>
 b64:	a8 c0       	rjmp	.+336    	; 0xcb6 <main+0x2e4>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:103
			delay(11);//Necessary to not overwhelm the ID-XXLA module baud rate.
 b66:	9e db       	rcall	.-2244   	; 0x2a4 <delay.constprop.0>
 b68:	83 ef       	ldi	r24, 0xF3	; 243
 b6a:	e8 2e       	mov	r14, r24
 b6c:	80 e0       	ldi	r24, 0x00	; 0
 b6e:	f8 2e       	mov	r15, r24
 b70:	67 01       	movw	r12, r14
getTagID():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:128
bool getTagID() 
{
	int j = 0; 
	for( int i = 0; i < TAG_ID_SIZE - 1 ; i ++ ) //TAG_ID_SIZE IS 16, but an index is numerically one less (0-15).
	{
		tempInc[i] = atSerial.read(); 	
 b72:	81 ed       	ldi	r24, 0xD1	; 209
 b74:	91 e0       	ldi	r25, 0x01	; 1
 b76:	5f dc       	rcall	.-1858   	; 0x436 <SoftwareSerial::read()>
 b78:	f6 01       	movw	r30, r12
 b7a:	81 93       	st	Z+, r24
 b7c:	6f 01       	movw	r12, r30
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:129
		delay(11); //The delay keeps the read commands from outpacing the baud rate of 9600.
 b7e:	92 db       	rcall	.-2268   	; 0x2a4 <delay.constprop.0>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:126
// are converted to the decimal equivalent values and saved into another temporaray array. The value
// is validated and then passed into the final array ready to be sent on the I2C bus.
bool getTagID() 
{
	int j = 0; 
	for( int i = 0; i < TAG_ID_SIZE - 1 ; i ++ ) //TAG_ID_SIZE IS 16, but an index is numerically one less (0-15).
 b80:	cc 15       	cp	r28, r12
 b82:	dd 05       	cpc	r29, r13
 b84:	b1 f7       	brne	.-20     	; 0xb72 <main+0x1a0>
main():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:125
// and the individual elements of the temporary array are passed to another function where they 
// are converted to the decimal equivalent values and saved into another temporaray array. The value
// is validated and then passed into the final array ready to be sent on the I2C bus.
bool getTagID() 
{
	int j = 0; 
 b86:	50 e0       	ldi	r21, 0x00	; 0
 b88:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:131
	for( int i = 0; i < TAG_ID_SIZE - 1 ; i ++ ) //TAG_ID_SIZE IS 16, but an index is numerically one less (0-15).
	{
		tempInc[i] = atSerial.read(); 	
		delay(11); //The delay keeps the read commands from outpacing the baud rate of 9600.
	}
	for( int i = 0; i < TAG_ID_SIZE - 1; i ++ ) 
 b8a:	30 e0       	ldi	r19, 0x00	; 0
 b8c:	20 e0       	ldi	r18, 0x00	; 0
getTagID():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:133
	{
		if( i % 2 == 0 && i !=0 ) j++; 
 b8e:	b9 01       	movw	r22, r18
 b90:	61 70       	andi	r22, 0x01	; 1
 b92:	77 27       	eor	r23, r23
 b94:	20 fd       	sbrc	r18, 0
 b96:	05 c0       	rjmp	.+10     	; 0xba2 <main+0x1d0>
 b98:	21 15       	cp	r18, r1
 b9a:	31 05       	cpc	r19, r1
 b9c:	11 f0       	breq	.+4      	; 0xba2 <main+0x1d0>
 b9e:	4f 5f       	subi	r20, 0xFF	; 255
 ba0:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:134
		if( tempInc[i] == endByte ) break;
 ba2:	f7 01       	movw	r30, r14
 ba4:	91 91       	ld	r25, Z+
 ba6:	7f 01       	movw	r14, r30
 ba8:	93 30       	cpi	r25, 0x03	; 3
 baa:	11 f1       	breq	.+68     	; 0xbf0 <main+0x21e>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:135
		else if( i > 10 && (tempInc[i] == cRHex || tempInc[i] == lFHex)) continue; //Not part of the TAG ID
 bac:	2b 30       	cpi	r18, 0x0B	; 11
 bae:	31 05       	cpc	r19, r1
 bb0:	24 f0       	brlt	.+8      	; 0xbba <main+0x1e8>
 bb2:	9d 30       	cpi	r25, 0x0D	; 13
 bb4:	c1 f0       	breq	.+48     	; 0xbe6 <main+0x214>
 bb6:	9a 30       	cpi	r25, 0x0A	; 10
 bb8:	b1 f0       	breq	.+44     	; 0xbe6 <main+0x214>
 bba:	80 ed       	ldi	r24, 0xD0	; 208
 bbc:	89 0f       	add	r24, r25
 bbe:	fa 01       	movw	r30, r20
 bc0:	e3 51       	subi	r30, 0x13	; 19
 bc2:	ff 4f       	sbci	r31, 0xFF	; 255
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:136
		else if( i % 2 == 0 ) tempTagID[j] = convertAscii(tempInc[i]) << 4; //MSB
 bc4:	67 2b       	or	r22, r23
 bc6:	09 f0       	breq	.+2      	; 0xbca <main+0x1f8>
 bc8:	67 c0       	rjmp	.+206    	; 0xc98 <main+0x2c6>
convertAscii():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:157
// Changes Ascii Values to their decimal representation by subtracting a fixed
// number, best understood by taking a look at an Ascii table. For example: we're 
// changing an Ascii zero, to an actual zero: ASCII "0" = 48 decimal.
byte convertAscii(byte asciiVal)
{
	if( asciiVal >= '0' && asciiVal <= '9' ) return asciiVal -= 48; 
 bca:	8a 30       	cpi	r24, 0x0A	; 10
 bcc:	38 f0       	brcs	.+14     	; 0xbdc <main+0x20a>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:158
	else if( asciiVal >= 'A' && asciiVal <= 'F' ) return asciiVal -= 55; 
 bce:	8f eb       	ldi	r24, 0xBF	; 191
 bd0:	89 0f       	add	r24, r25
 bd2:	86 30       	cpi	r24, 0x06	; 6
 bd4:	08 f0       	brcs	.+2      	; 0xbd8 <main+0x206>
 bd6:	5e c0       	rjmp	.+188    	; 0xc94 <main+0x2c2>
 bd8:	89 ec       	ldi	r24, 0xC9	; 201
 bda:	89 0f       	add	r24, r25
getTagID():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:136
	for( int i = 0; i < TAG_ID_SIZE - 1; i ++ ) 
	{
		if( i % 2 == 0 && i !=0 ) j++; 
		if( tempInc[i] == endByte ) break;
		else if( i > 10 && (tempInc[i] == cRHex || tempInc[i] == lFHex)) continue; //Not part of the TAG ID
		else if( i % 2 == 0 ) tempTagID[j] = convertAscii(tempInc[i]) << 4; //MSB
 bdc:	98 2f       	mov	r25, r24
 bde:	92 95       	swap	r25
 be0:	90 7f       	andi	r25, 0xF0	; 240
 be2:	90 83       	st	Z, r25
 be4:	18 2f       	mov	r17, r24
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:131
	for( int i = 0; i < TAG_ID_SIZE - 1 ; i ++ ) //TAG_ID_SIZE IS 16, but an index is numerically one less (0-15).
	{
		tempInc[i] = atSerial.read(); 	
		delay(11); //The delay keeps the read commands from outpacing the baud rate of 9600.
	}
	for( int i = 0; i < TAG_ID_SIZE - 1; i ++ ) 
 be6:	2f 5f       	subi	r18, 0xFF	; 255
 be8:	3f 4f       	sbci	r19, 0xFF	; 255
 bea:	2f 30       	cpi	r18, 0x0F	; 15
 bec:	31 05       	cpc	r19, r1
 bee:	79 f6       	brne	.-98     	; 0xb8e <main+0x1bc>
checkSum():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:164
}

//Double checking checksum value given by the tag module just in case something went wrong along the way.
bool checkSum(byte* uncheckedTag)
{
	byte exOr = uncheckedTag[0]; 
 bf0:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <tempTagID>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:167
	for( int i = 1; i < 5 ; i ++)
	{
		exOr ^= uncheckedTag[i];
 bf4:	90 91 ee 00 	lds	r25, 0x00EE	; 0x8000ee <tempTagID+0x1>
 bf8:	89 27       	eor	r24, r25
 bfa:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <tempTagID+0x2>
 bfe:	89 27       	eor	r24, r25
 c00:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <tempTagID+0x3>
 c04:	89 27       	eor	r24, r25
 c06:	90 91 f1 00 	lds	r25, 0x00F1	; 0x8000f1 <tempTagID+0x4>
 c0a:	89 27       	eor	r24, r25
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:169
	}
	if( exOr == uncheckedTag[5] ) return true; 
 c0c:	90 91 f2 00 	lds	r25, 0x00F2	; 0x8000f2 <tempTagID+0x5>
 c10:	89 13       	cpse	r24, r25
 c12:	9d cf       	rjmp	.-198    	; 0xb4e <main+0x17c>
 c14:	ad ee       	ldi	r26, 0xED	; 237
 c16:	b0 e0       	ldi	r27, 0x00	; 0
main():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:143
	}
	j=0;

	if( checkSum(tempTagID) )
	{
		for( int i = 0; i < 6; i++ )
 c18:	30 e0       	ldi	r19, 0x00	; 0
 c1a:	20 e0       	ldi	r18, 0x00	; 0
getTagID():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:145
		{
			tagEvent[newestTag].tagID[i] = tempTagID[i];
 c1c:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <newestTag>
 c20:	4d 91       	ld	r20, X+
 c22:	90 e0       	ldi	r25, 0x00	; 0
 c24:	6a e0       	ldi	r22, 0x0A	; 10
 c26:	70 e0       	ldi	r23, 0x00	; 0
 c28:	fc d0       	rcall	.+504    	; 0xe22 <__mulhi3>
 c2a:	88 5f       	subi	r24, 0xF8	; 248
 c2c:	9e 4f       	sbci	r25, 0xFE	; 254
 c2e:	fc 01       	movw	r30, r24
 c30:	e2 0f       	add	r30, r18
 c32:	f3 1f       	adc	r31, r19
 c34:	40 83       	st	Z, r20
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:143
	}
	j=0;

	if( checkSum(tempTagID) )
	{
		for( int i = 0; i < 6; i++ )
 c36:	2f 5f       	subi	r18, 0xFF	; 255
 c38:	3f 4f       	sbci	r19, 0xFF	; 255
 c3a:	26 30       	cpi	r18, 0x06	; 6
 c3c:	31 05       	cpc	r19, r1
 c3e:	71 f7       	brne	.-36     	; 0xc1c <main+0x24a>
loop():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:104
	{
		while( atSerial.available() ) 
		{	
			if( atSerial.read() != startByte ) break; 
			delay(11);//Necessary to not overwhelm the ID-XXLA module baud rate.
			if( getTagID() ) tagEvent[newestTag].tagTime = millis(); //Get the Tag ID, and verify its' contents, then grab time. 
 c40:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <newestTag>
millis():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:167
  }

  unsigned long millis()
  {
    unsigned long m;
    uint8_t oldSREG = SREG;
 c44:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:171

    // disable interrupts while we read millis_timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
    cli();
 c46:	f8 94       	cli
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:172
    m = millis_timer_millis;
 c48:	c0 90 03 01 	lds	r12, 0x0103	; 0x800103 <millis_timer_millis>
 c4c:	d0 90 04 01 	lds	r13, 0x0104	; 0x800104 <millis_timer_millis+0x1>
 c50:	e0 90 05 01 	lds	r14, 0x0105	; 0x800105 <millis_timer_millis+0x2>
 c54:	f0 90 06 01 	lds	r15, 0x0106	; 0x800106 <millis_timer_millis+0x3>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/wiring.c:173
    SREG = oldSREG;
 c58:	9f bf       	out	0x3f, r25	; 63
loop():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:104
 c5a:	90 e0       	ldi	r25, 0x00	; 0
 c5c:	6a e0       	ldi	r22, 0x0A	; 10
 c5e:	70 e0       	ldi	r23, 0x00	; 0
 c60:	e0 d0       	rcall	.+448    	; 0xe22 <__mulhi3>
 c62:	88 5f       	subi	r24, 0xF8	; 248
 c64:	9e 4f       	sbci	r25, 0xFE	; 254
 c66:	fc 01       	movw	r30, r24
 c68:	c6 82       	std	Z+6, r12	; 0x06
 c6a:	d7 82       	std	Z+7, r13	; 0x07
 c6c:	e0 86       	std	Z+8, r14	; 0x08
 c6e:	f1 86       	std	Z+9, r15	; 0x09
 c70:	6e cf       	rjmp	.-292    	; 0xb4e <main+0x17c>
begin():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:362
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
 c72:	2a e0       	ldi	r18, 0x0A	; 10
 c74:	30 e0       	ldi	r19, 0x00	; 0
 c76:	24 1b       	sub	r18, r20
 c78:	35 0b       	sbc	r19, r21
 c7a:	81 e0       	ldi	r24, 0x01	; 1
 c7c:	01 c0       	rjmp	.+2      	; 0xc80 <main+0x2ae>
 c7e:	88 0f       	add	r24, r24
 c80:	2a 95       	dec	r18
 c82:	ea f7       	brpl	.-6      	; 0xc7e <main+0x2ac>
 c84:	07 cf       	rjmp	.-498    	; 0xa94 <main+0xc2>
readSystemSettings():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:247
  {
    setting_i2c_address = I2C_ADDRESS_DEFAULT; //By default, we listen for I2C_ADDRESS_DEFAULT
    EEPROM.write(LOCATION_I2C_ADDRESS, setting_i2c_address);
  }

  else if( setting_i2c_address != I2C_ADDRESS_DEFAULT ) {
 c86:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <setting_i2c_address>
 c8a:	83 31       	cpi	r24, 0x13	; 19
 c8c:	09 f4       	brne	.+2      	; 0xc90 <main+0x2be>
 c8e:	56 cf       	rjmp	.-340    	; 0xb3c <main+0x16a>
operator=():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\EEPROM/EEPROM.h:61
 c90:	63 e1       	ldi	r22, 0x13	; 19
 c92:	51 cf       	rjmp	.-350    	; 0xb36 <main+0x164>
convertAscii():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:158
// number, best understood by taking a look at an Ascii table. For example: we're 
// changing an Ascii zero, to an actual zero: ASCII "0" = 48 decimal.
byte convertAscii(byte asciiVal)
{
	if( asciiVal >= '0' && asciiVal <= '9' ) return asciiVal -= 48; 
	else if( asciiVal >= 'A' && asciiVal <= 'F' ) return asciiVal -= 55; 
 c94:	81 2f       	mov	r24, r17
 c96:	a2 cf       	rjmp	.-188    	; 0xbdc <main+0x20a>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:157
// Changes Ascii Values to their decimal representation by subtracting a fixed
// number, best understood by taking a look at an Ascii table. For example: we're 
// changing an Ascii zero, to an actual zero: ASCII "0" = 48 decimal.
byte convertAscii(byte asciiVal)
{
	if( asciiVal >= '0' && asciiVal <= '9' ) return asciiVal -= 48; 
 c98:	8a 30       	cpi	r24, 0x0A	; 10
 c9a:	30 f0       	brcs	.+12     	; 0xca8 <main+0x2d6>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:158
	else if( asciiVal >= 'A' && asciiVal <= 'F' ) return asciiVal -= 55; 
 c9c:	8f eb       	ldi	r24, 0xBF	; 191
 c9e:	89 0f       	add	r24, r25
 ca0:	86 30       	cpi	r24, 0x06	; 6
 ca2:	38 f4       	brcc	.+14     	; 0xcb2 <main+0x2e0>
 ca4:	89 ec       	ldi	r24, 0xC9	; 201
 ca6:	89 0f       	add	r24, r25
getTagID():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:137
	{
		if( i % 2 == 0 && i !=0 ) j++; 
		if( tempInc[i] == endByte ) break;
		else if( i > 10 && (tempInc[i] == cRHex || tempInc[i] == lFHex)) continue; //Not part of the TAG ID
		else if( i % 2 == 0 ) tempTagID[j] = convertAscii(tempInc[i]) << 4; //MSB
		else ( tempTagID[j] |= convertAscii(tempInc[i]) );//LSB
 ca8:	90 81       	ld	r25, Z
 caa:	98 2b       	or	r25, r24
 cac:	90 83       	st	Z, r25
 cae:	08 2f       	mov	r16, r24
 cb0:	9a cf       	rjmp	.-204    	; 0xbe6 <main+0x214>
convertAscii():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:158
// number, best understood by taking a look at an Ascii table. For example: we're 
// changing an Ascii zero, to an actual zero: ASCII "0" = 48 decimal.
byte convertAscii(byte asciiVal)
{
	if( asciiVal >= '0' && asciiVal <= '9' ) return asciiVal -= 48; 
	else if( asciiVal >= 'A' && asciiVal <= 'F' ) return asciiVal -= 55; 
 cb2:	80 2f       	mov	r24, r16
 cb4:	f9 cf       	rjmp	.-14     	; 0xca8 <main+0x2d6>
loop():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:106
		{	
			if( atSerial.read() != startByte ) break; 
			delay(11);//Necessary to not overwhelm the ID-XXLA module baud rate.
			if( getTagID() ) tagEvent[newestTag].tagTime = millis(); //Get the Tag ID, and verify its' contents, then grab time. 
		}
		if( newestTag++ == MAX_TAG_STORAGE ) newestTag = 0; 
 cb6:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <newestTag>
 cba:	91 e0       	ldi	r25, 0x01	; 1
 cbc:	98 0f       	add	r25, r24
 cbe:	90 93 d0 01 	sts	0x01D0, r25	; 0x8001d0 <newestTag>
 cc2:	84 31       	cpi	r24, 0x14	; 20
 cc4:	11 f4       	brne	.+4      	; 0xcca <main+0x2f8>
 cc6:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <newestTag>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:110
	}

  //Set interrupt pin as needed
  if(newestTag != oldestTag	)
 cca:	90 91 d0 01 	lds	r25, 0x01D0	; 0x8001d0 <newestTag>
 cce:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <oldestTag>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:111
    digitalWrite(interruptPin, LOW); //We have tags on the stack!
 cd2:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:110
		}
		if( newestTag++ == MAX_TAG_STORAGE ) newestTag = 0; 
	}

  //Set interrupt pin as needed
  if(newestTag != oldestTag	)
 cd4:	98 13       	cpse	r25, r24
 cd6:	01 c0       	rjmp	.+2      	; 0xcda <main+0x308>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:113
    digitalWrite(interruptPin, LOW); //We have tags on the stack!
  else
    digitalWrite(interruptPin, HIGH); //No tag events to report
 cd8:	61 e0       	ldi	r22, 0x01	; 1
 cda:	83 e0       	ldi	r24, 0x03	; 3
 cdc:	46 da       	rcall	.-2932   	; 0x16a <digitalWrite>
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:115

  sleep_mode(); //Stop everything and go to sleep. Wake up if I2C event occurs.
 cde:	85 b7       	in	r24, 0x35	; 53
 ce0:	80 62       	ori	r24, 0x20	; 32
 ce2:	85 bf       	out	0x35, r24	; 53
 ce4:	88 95       	sleep
 ce6:	85 b7       	in	r24, 0x35	; 53
 ce8:	8f 7d       	andi	r24, 0xDF	; 223
 cea:	85 bf       	out	0x35, r24	; 53
 cec:	2a cf       	rjmp	.-428    	; 0xb42 <main+0x170>

00000cee <_GLOBAL__sub_I_setting_i2c_address>:
_ZN5PrintC2Ev():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Print.h:75
  public:
    Print() : write_error(0) {}
 cee:	10 92 d4 01 	sts	0x01D4, r1	; 0x8001d4 <atSerial+0x3>
 cf2:	10 92 d3 01 	sts	0x01D3, r1	; 0x8001d3 <atSerial+0x2>
_ZN6StreamC2Ev():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\cores\tiny/Stream.h:64
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 cf6:	88 ee       	ldi	r24, 0xE8	; 232
 cf8:	93 e0       	ldi	r25, 0x03	; 3
 cfa:	a0 e0       	ldi	r26, 0x00	; 0
 cfc:	b0 e0       	ldi	r27, 0x00	; 0
 cfe:	80 93 d5 01 	sts	0x01D5, r24	; 0x8001d5 <atSerial+0x4>
 d02:	90 93 d6 01 	sts	0x01D6, r25	; 0x8001d6 <atSerial+0x5>
 d06:	a0 93 d7 01 	sts	0x01D7, r26	; 0x8001d7 <atSerial+0x6>
 d0a:	b0 93 d8 01 	sts	0x01D8, r27	; 0x8001d8 <atSerial+0x7>
_GLOBAL__sub_I_setting_i2c_address():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:253
  _rx_delay_centering(0),
  _rx_delay_intrabit(0),
  _rx_delay_stopbit(0),
  _tx_delay(0),
  _buffer_overflow(false),
  _inverse_logic(inverse_logic)
 d0e:	86 e6       	ldi	r24, 0x66	; 102
 d10:	90 e0       	ldi	r25, 0x00	; 0
 d12:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <atSerial+0x1>
 d16:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <atSerial>
 d1a:	10 92 e8 01 	sts	0x01E8, r1	; 0x8001e8 <atSerial+0x17>
 d1e:	10 92 e7 01 	sts	0x01E7, r1	; 0x8001e7 <atSerial+0x16>
 d22:	10 92 ea 01 	sts	0x01EA, r1	; 0x8001ea <atSerial+0x19>
 d26:	10 92 e9 01 	sts	0x01E9, r1	; 0x8001e9 <atSerial+0x18>
 d2a:	10 92 ec 01 	sts	0x01EC, r1	; 0x8001ec <atSerial+0x1b>
 d2e:	10 92 eb 01 	sts	0x01EB, r1	; 0x8001eb <atSerial+0x1a>
 d32:	10 92 ee 01 	sts	0x01EE, r1	; 0x8001ee <atSerial+0x1d>
 d36:	10 92 ed 01 	sts	0x01ED, r1	; 0x8001ed <atSerial+0x1c>
 d3a:	60 91 ef 01 	lds	r22, 0x01EF	; 0x8001ef <atSerial+0x1e>
 d3e:	6e 7f       	andi	r22, 0xFE	; 254
 d40:	6d 7f       	andi	r22, 0xFD	; 253
 d42:	60 93 ef 01 	sts	0x01EF, r22	; 0x8001ef <atSerial+0x1e>
setTX():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:273
{
  // First write, then set output. If we do this the other way around,
  // the pin would be output low for a short while before switching to
  // output hihg. Now, it is input with pullup for a short while, which
  // is fine. With inverse logic, either order is fine.
  digitalWrite(tx, _inverse_logic ? LOW : HIGH);
 d46:	66 95       	lsr	r22
 d48:	61 70       	andi	r22, 0x01	; 1
 d4a:	81 e0       	ldi	r24, 0x01	; 1
 d4c:	68 27       	eor	r22, r24
 d4e:	0d da       	rcall	.-3046   	; 0x16a <digitalWrite>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:274
  pinMode(tx, OUTPUT);
 d50:	61 e0       	ldi	r22, 0x01	; 1
 d52:	81 e0       	ldi	r24, 0x01	; 1
 d54:	45 da       	rcall	.-2934   	; 0x1e0 <pinMode>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:275
  _transmitBitMask = digitalPinToBitMask(tx);
 d56:	e1 e4       	ldi	r30, 0x41	; 65
 d58:	f0 e0       	ldi	r31, 0x00	; 0
 d5a:	e4 91       	lpm	r30, Z
 d5c:	e0 93 e1 01 	sts	0x01E1, r30	; 0x8001e1 <atSerial+0x10>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:276
  uint8_t port = digitalPinToPort(tx);
 d60:	e5 e3       	ldi	r30, 0x35	; 53
 d62:	f0 e0       	ldi	r31, 0x00	; 0
 d64:	e4 91       	lpm	r30, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:277
  _transmitPortRegister = portOutputRegister(port);
 d66:	f0 e0       	ldi	r31, 0x00	; 0
 d68:	ee 0f       	add	r30, r30
 d6a:	ff 1f       	adc	r31, r31
 d6c:	e2 5d       	subi	r30, 0xD2	; 210
 d6e:	ff 4f       	sbci	r31, 0xFF	; 255
 d70:	85 91       	lpm	r24, Z+
 d72:	94 91       	lpm	r25, Z
 d74:	90 93 e3 01 	sts	0x01E3, r25	; 0x8001e3 <atSerial+0x12>
 d78:	80 93 e2 01 	sts	0x01E2, r24	; 0x8001e2 <atSerial+0x11>
setRX():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:282
}

void SoftwareSerial::setRX(uint8_t rx)
{
  pinMode(rx, INPUT);
 d7c:	60 e0       	ldi	r22, 0x00	; 0
 d7e:	82 e0       	ldi	r24, 0x02	; 2
 d80:	2f da       	rcall	.-2978   	; 0x1e0 <pinMode>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:283
  if (!_inverse_logic)
 d82:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <atSerial+0x1e>
 d86:	81 fd       	sbrc	r24, 1
 d88:	03 c0       	rjmp	.+6      	; 0xd90 <_GLOBAL__sub_I_setting_i2c_address+0xa2>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:284
    digitalWrite(rx, HIGH);  // pullup for normal logic!
 d8a:	61 e0       	ldi	r22, 0x01	; 1
 d8c:	82 e0       	ldi	r24, 0x02	; 2
 d8e:	ed d9       	rcall	.-3110   	; 0x16a <digitalWrite>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:285
  _receivePin = rx;
 d90:	82 e0       	ldi	r24, 0x02	; 2
 d92:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <atSerial+0xc>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:286
  _receiveBitMask = digitalPinToBitMask(rx);
 d96:	e2 e4       	ldi	r30, 0x42	; 66
 d98:	f0 e0       	ldi	r31, 0x00	; 0
 d9a:	e4 91       	lpm	r30, Z
 d9c:	e0 93 de 01 	sts	0x01DE, r30	; 0x8001de <atSerial+0xd>
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:287
  uint8_t port = digitalPinToPort(rx);
 da0:	e6 e3       	ldi	r30, 0x36	; 54
 da2:	f0 e0       	ldi	r31, 0x00	; 0
 da4:	e4 91       	lpm	r30, Z
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:288
  _receivePortRegister = portInputRegister(port);
 da6:	f0 e0       	ldi	r31, 0x00	; 0
 da8:	ee 0f       	add	r30, r30
 daa:	ff 1f       	adc	r31, r31
 dac:	ee 5d       	subi	r30, 0xDE	; 222
 dae:	ff 4f       	sbci	r31, 0xFF	; 255
 db0:	85 91       	lpm	r24, Z+
 db2:	94 91       	lpm	r25, Z
 db4:	90 93 e0 01 	sts	0x01E0, r25	; 0x8001e0 <atSerial+0xf>
 db8:	80 93 df 01 	sts	0x01DF, r24	; 0x8001df <atSerial+0xe>
_GLOBAL__sub_I_setting_i2c_address():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:266
    Wire.begin(I2C_ADDRESS_NO_JUMPER); //Force address to I2C_ADDRESS_NO_JUMPER if user has opened the solder jumper

  //The connections to the interrupts are severed when a Wire.begin occurs. So re-declare them.
  Wire.onReceive(receiveEvent);
  Wire.onRequest(requestEvent);
}
 dbc:	08 95       	ret

00000dbe <_GLOBAL__sub_D_setting_i2c_address>:
_GLOBAL__sub_D_setting_i2c_address():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:262
}

//
// Destructor
//
SoftwareSerial::~SoftwareSerial()
 dbe:	86 e6       	ldi	r24, 0x66	; 102
 dc0:	90 e0       	ldi	r25, 0x00	; 0
 dc2:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <atSerial+0x1>
 dc6:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <atSerial>
stopListening():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:109
}

// Stop listening. Returns true if we were actually listening.
bool SoftwareSerial::stopListening()
{
  if (active_object == this)
 dca:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <SoftwareSerial::active_object>
 dce:	90 91 ec 00 	lds	r25, 0x00EC	; 0x8000ec <SoftwareSerial::active_object+0x1>
 dd2:	81 5d       	subi	r24, 0xD1	; 209
 dd4:	91 40       	sbci	r25, 0x01	; 1
 dd6:	71 f4       	brne	.+28     	; 0xdf4 <_GLOBAL__sub_D_setting_i2c_address+0x36>
setRxIntMsk():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:380
void SoftwareSerial::setRxIntMsk(bool enable)
{
    if (enable)
      *_pcint_maskreg |= _pcint_maskvalue;
    else
      *_pcint_maskreg &= ~_pcint_maskvalue;
 dd8:	e0 91 e4 01 	lds	r30, 0x01E4	; 0x8001e4 <atSerial+0x13>
 ddc:	f0 91 e5 01 	lds	r31, 0x01E5	; 0x8001e5 <atSerial+0x14>
 de0:	90 81       	ld	r25, Z
 de2:	80 91 e6 01 	lds	r24, 0x01E6	; 0x8001e6 <atSerial+0x15>
 de6:	80 95       	com	r24
 de8:	89 23       	and	r24, r25
 dea:	80 83       	st	Z, r24
stopListening():
C:\Users\Elias\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.4.1\libraries\SoftwareSerial/SoftwareSerial.cpp:112
bool SoftwareSerial::stopListening()
{
  if (active_object == this)
  {
    setRxIntMsk(false);
    active_object = NULL;
 dec:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <SoftwareSerial::active_object+0x1>
 df0:	10 92 eb 00 	sts	0x00EB, r1	; 0x8000eb <SoftwareSerial::active_object>
_GLOBAL__sub_D_setting_i2c_address():
C:\Users\Elias\Documents\Github\SparkFun_Qwiic_RFID_ID-XXLA\Firmware\ATtiny85_Firmware\Qwiic_RFID_IDXXLA/Qwiic_RFID_IDXXLA.ino:266
 df4:	08 95       	ret

00000df6 <eeprom_read_byte>:
eeprom_read_byte():
 df6:	e1 99       	sbic	0x1c, 1	; 28
 df8:	fe cf       	rjmp	.-4      	; 0xdf6 <eeprom_read_byte>
 dfa:	9f bb       	out	0x1f, r25	; 31
 dfc:	8e bb       	out	0x1e, r24	; 30
 dfe:	e0 9a       	sbi	0x1c, 0	; 28
 e00:	99 27       	eor	r25, r25
 e02:	8d b3       	in	r24, 0x1d	; 29
 e04:	08 95       	ret

00000e06 <eeprom_write_byte>:
eeprom_write_byte():
 e06:	26 2f       	mov	r18, r22

00000e08 <eeprom_write_r18>:
 e08:	e1 99       	sbic	0x1c, 1	; 28
 e0a:	fe cf       	rjmp	.-4      	; 0xe08 <eeprom_write_r18>
 e0c:	1c ba       	out	0x1c, r1	; 28
 e0e:	9f bb       	out	0x1f, r25	; 31
 e10:	8e bb       	out	0x1e, r24	; 30
 e12:	2d bb       	out	0x1d, r18	; 29
 e14:	0f b6       	in	r0, 0x3f	; 63
 e16:	f8 94       	cli
 e18:	e2 9a       	sbi	0x1c, 2	; 28
 e1a:	e1 9a       	sbi	0x1c, 1	; 28
 e1c:	0f be       	out	0x3f, r0	; 63
 e1e:	01 96       	adiw	r24, 0x01	; 1
 e20:	08 95       	ret

00000e22 <__mulhi3>:
__mulhi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:312
 e22:	00 24       	eor	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:313
 e24:	55 27       	eor	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:314
 e26:	04 c0       	rjmp	.+8      	; 0xe30 <__mulhi3+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:317
 e28:	08 0e       	add	r0, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:318
 e2a:	59 1f       	adc	r21, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:320
 e2c:	88 0f       	add	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:321
 e2e:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:324
 e30:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:325
 e32:	29 f0       	breq	.+10     	; 0xe3e <__mulhi3+0x1c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:328
 e34:	76 95       	lsr	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:329
 e36:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:331
 e38:	b8 f3       	brcs	.-18     	; 0xe28 <__mulhi3+0x6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:335
 e3a:	71 05       	cpc	r23, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:337
 e3c:	b9 f7       	brne	.-18     	; 0xe2c <__mulhi3+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:340
 e3e:	80 2d       	mov	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:341
 e40:	95 2f       	mov	r25, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:342
 e42:	08 95       	ret

00000e44 <__divmodhi4>:
__divmodhi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1440
 e44:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1441
 e46:	07 2e       	mov	r0, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1442
 e48:	16 f4       	brtc	.+4      	; 0xe4e <__divmodhi4+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1443
 e4a:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1444
 e4c:	06 d0       	rcall	.+12     	; 0xe5a <__divmodhi4_neg1>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1446
 e4e:	77 fd       	sbrc	r23, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1447
 e50:	08 d0       	rcall	.+16     	; 0xe62 <__divmodhi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1448
 e52:	0b d0       	rcall	.+22     	; 0xe6a <__udivmodhi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1449
 e54:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1450
 e56:	05 d0       	rcall	.+10     	; 0xe62 <__divmodhi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1451
 e58:	3e f4       	brtc	.+14     	; 0xe68 <__divmodhi4_exit>

00000e5a <__divmodhi4_neg1>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1454
 e5a:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1455
 e5c:	81 95       	neg	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1456
 e5e:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1457
 e60:	08 95       	ret

00000e62 <__divmodhi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1460
 e62:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1461
 e64:	61 95       	neg	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1462
 e66:	7f 4f       	sbci	r23, 0xFF	; 255

00000e68 <__divmodhi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1464
 e68:	08 95       	ret

00000e6a <__udivmodhi4>:
__udivmodhi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
 e6a:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
 e6c:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
 e6e:	51 e1       	ldi	r21, 0x11	; 17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
 e70:	07 c0       	rjmp	.+14     	; 0xe80 <__udivmodhi4_ep>

00000e72 <__udivmodhi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
 e72:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
 e74:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
 e76:	a6 17       	cp	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
 e78:	b7 07       	cpc	r27, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
 e7a:	10 f0       	brcs	.+4      	; 0xe80 <__udivmodhi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
 e7c:	a6 1b       	sub	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
 e7e:	b7 0b       	sbc	r27, r23

00000e80 <__udivmodhi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
 e80:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
 e82:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
 e84:	5a 95       	dec	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
 e86:	a9 f7       	brne	.-22     	; 0xe72 <__udivmodhi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
 e88:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
 e8a:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
 e8c:	bc 01       	movw	r22, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
 e8e:	cd 01       	movw	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
 e90:	08 95       	ret

00000e92 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 e92:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 e94:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 e96:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 e98:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 e9a:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 e9c:	09 94       	ijmp

00000e9e <__do_global_dtors>:
__do_global_dtors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
 e9e:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
 ea0:	cd e2       	ldi	r28, 0x2D	; 45
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
 ea2:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
 ea4:	03 c0       	rjmp	.+6      	; 0xeac <__do_global_dtors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
 ea6:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
 ea8:	f4 df       	rcall	.-24     	; 0xe92 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
 eaa:	21 96       	adiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
 eac:	ce 32       	cpi	r28, 0x2E	; 46
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
 eae:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
 eb0:	d1 f7       	brne	.-12     	; 0xea6 <__do_global_dtors+0x8>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 eb2:	f8 94       	cli

00000eb4 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 eb4:	ff cf       	rjmp	.-2      	; 0xeb4 <__stop_program>
